System.register(["react-query","jotai"],function(w){"use strict";var Q,O,P,g,l;return{setters:[function(s){Q=s.QueryClient,O=s.QueryObserver,P=s.InfiniteQueryObserver,g=s.isCancelledError},function(s){l=s.atom}],execute:function(){w({atomWithInfiniteQuery:E,atomWithQuery:A});const s=w("queryClientAtom",l(new Q));function A(i,v=a=>a(s)){const a=l(r=>{const o=v(r),t=typeof i=="function"?i(r):i;let n=null;const u=(()=>{let e=o.getQueryData(t.queryKey);return e===void 0&&t.initialData&&(e=typeof t.initialData=="function"?t.initialData():t.initialData),e})(),f=l(u===void 0&&t.enabled!==!1?new Promise((e,m)=>{n=(p,h)=>{h?m(h):e(p)}}):u);let d=()=>{throw new Error("atomWithQuery: setting data without mount")};const y=e=>{if(e.error){n?(n(void 0,e.error),n=null):d(Promise.reject(e.error));return}e.data!==void 0&&(n?(n(e.data),n=null):d(e.data))},c=o.defaultQueryObserverOptions(t);u===void 0&&t.enabled!==!1&&typeof c.staleTime!="number"&&(c.staleTime=1e3);const b=new O(o,c);return u===void 0&&t.enabled!==!1&&b.fetchOptimistic(c).then(y).catch(e=>y({error:e})),f.onMount=e=>{if(d=e,t.enabled!==!1)return b.subscribe(y)},{dataAtom:f,observer:b}},(r,o,t)=>{switch(t.type){case"refetch":{const{dataAtom:n,observer:u}=r(a);return o(n,new Promise(()=>{})),Promise.resolve().then(()=>u.refetch({cancelRefetch:!0})).then(()=>{})}default:throw new Error("no action")}});return l(r=>{const{dataAtom:o}=r(a);return r(o)},(r,o,t)=>o(a,t))}var D=Object.getOwnPropertySymbols,I=Object.prototype.hasOwnProperty,j=Object.prototype.propertyIsEnumerable,C=(i,v)=>{var a={};for(var r in i)I.call(i,r)&&v.indexOf(r)<0&&(a[r]=i[r]);if(i!=null&&D)for(var r of D(i))v.indexOf(r)<0&&j.call(i,r)&&(a[r]=i[r]);return a};function E(i,v=a=>a(s)){const a=l(r=>{const o=v(r),t=typeof i=="function"?i(r):i;let n=null;const u=(()=>{let e=o.getQueryData(t.queryKey);return e===void 0&&t.initialData&&(e=typeof t.initialData=="function"?t.initialData():t.initialData),e})(),f=l(u===void 0&&t.enabled!==!1?new Promise((e,m)=>{n=(p,h)=>{h?m(h):e(p)}}):u);let d=()=>{throw new Error("atomWithInfiniteQuery: setting data without mount")};const y=e=>{if(e.error&&!g(e.error)){n?(n(void 0,e.error),n=null):d(Promise.reject(e.error));return}e.data!==void 0&&(n?(n(e.data),n=null):d(e.data))},c=o.defaultQueryObserverOptions(t);u===void 0&&t.enabled!==!1&&typeof c.staleTime!="number"&&(c.staleTime=1e3);const b=new P(o,c);return u===void 0&&t.enabled!==!1&&b.fetchOptimistic(c).then(y).catch(e=>y({error:e})),f.onMount=e=>{if(d=e,t.enabled!==!1)return b.subscribe(y)},{dataAtom:f,observer:b,options:t}},(r,o,t)=>{const{observer:n}=r(a);switch(t.type){case"refetch":{const u=t,f=C(u,["type"]);n.refetch(f);break}case"fetchPreviousPage":{n.fetchPreviousPage();break}case"fetchNextPage":{n.fetchNextPage();break}}});return l(r=>{const{dataAtom:o}=r(a);return r(o)},(r,o,t)=>o(a,t))}}}});

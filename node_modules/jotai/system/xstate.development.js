System.register(['xstate', 'jotai'], (function (exports) {
  'use strict';
  var interpret, atom;
  return {
    setters: [function (module) {
      interpret = module.interpret;
    }, function (module) {
      atom = module.atom;
    }],
    execute: (function () {

      exports('atomWithMachine', atomWithMachine);

      var __defProp = Object.defineProperty;
      var __getOwnPropSymbols = Object.getOwnPropertySymbols;
      var __hasOwnProp = Object.prototype.hasOwnProperty;
      var __propIsEnum = Object.prototype.propertyIsEnumerable;
      var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
      var __spreadValues = (a, b) => {
        for (var prop in b || (b = {}))
          if (__hasOwnProp.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        if (__getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(b)) {
            if (__propIsEnum.call(b, prop))
              __defNormalProp(a, prop, b[prop]);
          }
        return a;
      };
      var __objRest = (source, exclude) => {
        var target = {};
        for (var prop in source)
          if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
            target[prop] = source[prop];
        if (source != null && __getOwnPropSymbols)
          for (var prop of __getOwnPropSymbols(source)) {
            if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
              target[prop] = source[prop];
          }
        return target;
      };
      function atomWithMachine(getMachine, getOptions) {
        const cachedMachineAtom = atom(null);
        const machineAtom = atom((get) => {
          const cachedMachine = get(cachedMachineAtom);
          if (cachedMachine) {
            return cachedMachine;
          }
          let initializing = true;
          const safeGet = (a) => {
            if (initializing) {
              return get(a);
            }
            throw new Error("get not allowed after initialization");
          };
          const machine = typeof getMachine === "function" ? getMachine(safeGet) : getMachine;
          const options = typeof getOptions === "function" ? getOptions(safeGet) : getOptions;
          initializing = false;
          const _a = options || {}, {
            guards,
            actions,
            activities,
            services,
            delays
          } = _a, interpreterOptions = __objRest(_a, [
            "guards",
            "actions",
            "activities",
            "services",
            "delays"
          ]);
          const machineConfig = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, guards && { guards }), actions && { actions }), activities && { activities }), services && { services }), delays && { delays });
          const machineWithConfig = machine.withConfig(machineConfig, machine.context);
          const service = interpret(machineWithConfig, interpreterOptions);
          return { machine: machineWithConfig, service };
        }, (get, set, _arg) => {
          set(cachedMachineAtom, get(machineAtom));
        });
        machineAtom.onMount = (commit) => {
          commit();
        };
        const cachedMachineStateAtom = atom(null);
        const machineStateAtom = atom((get) => {
          var _a;
          return (_a = get(cachedMachineStateAtom)) != null ? _a : get(machineAtom).machine.initialState;
        }, (get, set, registerCleanup) => {
          const { service } = get(machineAtom);
          service.onTransition((nextState) => {
            set(cachedMachineStateAtom, nextState);
          });
          service.start();
          registerCleanup(() => {
            service.stop();
          });
        });
        machineStateAtom.onMount = (initialize) => {
          let unsub;
          initialize((cleanup) => {
            if (unsub === false) {
              cleanup();
            } else {
              unsub = cleanup;
            }
          });
          return () => {
            if (unsub) {
              unsub();
            }
            unsub = false;
          };
        };
        const machineStateWithServiceAtom = atom((get) => get(machineStateAtom), (get, _set, event) => {
          const { service } = get(machineAtom);
          service.send(event);
        });
        return machineStateWithServiceAtom;
      }

    })
  };
}));

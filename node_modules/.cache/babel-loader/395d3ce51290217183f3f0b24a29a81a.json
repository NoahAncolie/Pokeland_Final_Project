{"ast":null,"code":"import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      const array = [];\n      const childNodes = xml.childNodes;\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName);\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {};\n      const target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      let parts = target.split('/');\n      const id = parts.shift();\n      let sid = parts.shift(); // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1;\n      const memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        const indices = sid.split('(');\n        sid = indices.shift();\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []; // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      }\n\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations = data.animations;\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i]);\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            const id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            const offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        const vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      const data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid');\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechniqueBump(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null; // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      const parameters = technique.parameters;\n\n      for (const key in parameters) {\n        const parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      let transparent = parameters['transparent'];\n      let transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique;\n\n        for (const k in techniques) {\n          const v = techniques[k];\n\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n\n            case 'bump':\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      let camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      let data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      let light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      const data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            const offset = parseInt(child.getAttribute('offset'));\n            const set = parseInt(child.getAttribute('set'));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {};\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0;\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives);\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv2 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs; // groups\n\n        let count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (const name in inputs) {\n          const input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride;\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      }\n\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      }\n\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        let index = 0;\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i];\n\n          if (count === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data;\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0];\n            const min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName\n      };\n      const array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          const parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name');\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            const joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            const matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material');\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute('symbol');\n              const target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j];\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      const bones = [];\n      const boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      const objects = [];\n      const matrix = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      let object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        let object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      const elements = getElementsByTagName(xml, 'node');\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      const clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          const tracks = [];\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      let result = '';\n      const stack = [parserError];\n\n      while (stack.length) {\n        const node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml');\n    const collada = getElementsByTagName(xml, 'COLLADA')[0];\n    const parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      const errorElement = getElementsByTagName(parserError, 'div')[0];\n      let errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    const version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    const animations = [];\n    let kinematics = {};\n    let count = 0; //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n\n}\n\nexport { ColladaLoader };","map":{"version":3,"names":["Loader","LoaderUtils","FileLoader","Vector3","Quaternion","Matrix4","MeshBasicMaterial","Scene","TextureLoader","Euler","MathUtils","AnimationClip","VectorKeyframeTrack","QuaternionKeyframeTrack","MeshLambertMaterial","MeshPhongMaterial","Vector2","DoubleSide","FrontSide","PerspectiveCamera","OrthographicCamera","Color","AmbientLight","SpotLight","PointLight","DirectionalLight","BufferGeometry","Float32BufferAttribute","Skeleton","Bone","Group","LineBasicMaterial","SkinnedMesh","Mesh","Line","LineSegments","RepeatWrapping","ClampToEdgeWrapping","TGALoader","ColladaLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","surface","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","pushVector","sourceStride","sourceArray","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","substr","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","DOMParser","parseFromString","errorElement","errorText","version","asset","resourcePath","setCrossOrigin","crossOrigin","setFromEuler","PI","multiplyScalar"],"sources":["/home/odin/Desktop/THP☠/Developpeur/Final_Project/pokeland/node_modules/three-stdlib/loaders/ColladaLoader.js"],"sourcesContent":["import { Loader, LoaderUtils, FileLoader, Vector3, Quaternion, Matrix4, MeshBasicMaterial, Scene, TextureLoader, Euler, MathUtils, AnimationClip, VectorKeyframeTrack, QuaternionKeyframeTrack, MeshLambertMaterial, MeshPhongMaterial, Vector2, DoubleSide, FrontSide, PerspectiveCamera, OrthographicCamera, Color, AmbientLight, SpotLight, PointLight, DirectionalLight, BufferGeometry, Float32BufferAttribute, Skeleton, Bone, Group, LineBasicMaterial, SkinnedMesh, Mesh, Line, LineSegments, RepeatWrapping, ClampToEdgeWrapping } from 'three';\nimport { TGALoader } from './TGALoader.js';\n\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n      const array = [];\n      const childNodes = xml.childNodes;\n\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n\n      return array;\n    }\n\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n\n      return array;\n    }\n\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n\n      return array;\n    }\n\n    function parseId(text) {\n      return text.substring(1);\n    }\n\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    } // asset\n\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    } // library\n\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0];\n\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName);\n\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    } // get\n\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    } // animation\n\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseAnimationChannel(xml) {\n      const data = {};\n      const target = xml.getAttribute('target'); // parsing SID Addressing Syntax\n\n      let parts = target.split('/');\n      const id = parts.shift();\n      let sid = parts.shift(); // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1;\n      const memberSyntax = sid.indexOf('.') !== -1;\n\n      if (memberSyntax) {\n        //  member selection access\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n        const indices = sid.split('(');\n        sid = indices.shift();\n\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n\n        data.indices = indices;\n      }\n\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n\n      return tracks;\n    }\n\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {}; // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n\n          break;\n\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = []; // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      } // ensure keyframes are sorted by time\n\n\n      keyframes.sort(ascending); // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n\n      return keyframes; // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n\n      if (quaternionData.length > 0) {\n        tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      }\n\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l; // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n\n      if (empty === true) {\n        // no values at all, so we set a default value\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n\n      return null;\n    }\n\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n\n      return null;\n    }\n\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    } // animation clips\n\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n\n      library.clips[xml.getAttribute('id')] = data;\n    }\n\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations = data.animations;\n\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i]);\n\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n\n      return new AnimationClip(name, duration, tracks);\n    }\n\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    } // controller\n\n\n    function parseController(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n\n    function parseSkin(xml) {\n      const data = {\n        sources: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n\n          case 'source':\n            const id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseJoints(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            const offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin); // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n\n      return build;\n    }\n\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l; // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n\n        const vertexSkinData = [];\n\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        } // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n\n        vertexSkinData.sort(descending); // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      } // setup bind matrix\n\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      } // process bones and inverse bind matrix data\n\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n\n      return build; // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    } // image\n\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n\n    function getImage(id) {\n      const data = library.images[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find image with ID:\", id);\n      return null;\n    } // effect\n\n\n    function parseEffect(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n\n      library.effects[xml.getAttribute('id')] = data;\n    }\n\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid');\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectSurface(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectSampler(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameter(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {}\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n\n            break;\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n\n    function parseEffectExtra(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseEffectExtraTechniqueBump(xml) {\n      var data = {};\n\n      for (var i = 0, l = xml.childNodes.length; i < l; i++) {\n        var child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildEffect(data) {\n      return data;\n    }\n\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    } // material\n\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n\n      library.materials[xml.getAttribute('id')] = data;\n    }\n\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n\n      extension = extension.toLowerCase();\n\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n\n        default:\n          loader = textureLoader;\n      }\n\n      return loader;\n    }\n\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n\n      material.name = data.name || '';\n\n      function getTexture(textureObject) {\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null; // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        } // create texture if image is avaiable\n\n\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n\n          if (loader !== undefined) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn(\"THREE.ColladaLoader: Couldn't create texture with ID:\", textureObject.id);\n          return null;\n        }\n      }\n\n      const parameters = technique.parameters;\n\n      for (const key in parameters) {\n        const parameter = parameters[key];\n\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture);\n            break;\n\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture);\n            break;\n\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture);\n            break;\n        }\n      } //\n\n\n      let transparent = parameters['transparent'];\n      let transparency = parameters['transparency']; // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      } // <transparent> does not exist but <transparency>\n\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n\n          if (material.opacity < 1) material.transparent = true;\n        }\n      } //\n\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique;\n\n        for (const k in techniques) {\n          const v = techniques[k];\n\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n\n            case 'bump':\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n\n      return material;\n    }\n\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    } // camera\n\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n\n      return {};\n    }\n\n    function parseCameraTechnique(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseCameraParameters(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildCamera(data) {\n      let camera;\n\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag, // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n\n      camera.name = data.name || '';\n      return camera;\n    }\n\n    function getCamera(id) {\n      const data = library.cameras[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find camera with ID:\", id);\n      return null;\n    } // light\n\n\n    function parseLight(xml) {\n      let data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n\n      library.lights[xml.getAttribute('id')] = data;\n    }\n\n    function parseLightTechnique(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n\n      return data;\n    }\n\n    function parseLightParameters(xml) {\n      const data = {};\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array);\n            break;\n\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildLight(data) {\n      let light;\n\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n\n        case 'point':\n          light = new PointLight();\n          break;\n\n        case 'spot':\n          light = new SpotLight();\n          break;\n\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n\n    function getLight(id) {\n      const data = library.lights[id];\n\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n\n      console.warn(\"THREE.ColladaLoader: Couldn't find light with ID:\", id);\n      return null;\n    } // geometry\n\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml, 'mesh')[0]; // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\n      if (mesh === undefined) return;\n\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute('id');\n\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0];\n\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseGeometryVertices(xml) {\n      const data = {};\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n\n      return data;\n    }\n\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            const offset = parseInt(child.getAttribute('offset'));\n            const set = parseInt(child.getAttribute('set'));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n\n      return primitive;\n    }\n\n    function groupPrimitives(primitives) {\n      const build = {};\n\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n\n      return build;\n    }\n\n    function checkUVCoordinates(primitives) {\n      let count = 0;\n\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {}; // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives);\n\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type]; // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType); // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n\n      return build;\n    }\n\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv2 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs; // groups\n\n        let count = 0;\n\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n\n                  break;\n\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n\n                  break;\n\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n\n                  break;\n              }\n            }\n\n            break;\n\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n\n        geometry.addGroup(start, count, p);\n        start += count; // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        } // geometry data\n\n\n        for (const name in inputs) {\n          const input = inputs[name];\n\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key];\n\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    } // see #3803\n\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride;\n\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n                        uv.array.push(0, 0);\n                      }\n                    }\n\n                    break;\n\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n\n              break;\n\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array);\n              color.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      } // build geometry\n\n\n      if (position.array.length > 0) {\n        geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      }\n\n      if (normal.array.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      }\n\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n\n      if (skinIndex.array.length > 0) {\n        geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      }\n\n      if (skinWeight.array.length > 0) {\n        geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      }\n\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n\n    function buildGeometryData(primitive, source, offset, array) {\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n      }\n\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n\n      if (primitive.vcount !== undefined) {\n        let index = 0;\n\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i];\n\n          if (count === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    } // kinematics\n\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n\n    function parseKinematicsJoint(xml) {\n      let data;\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0];\n            const min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      } // if min is equal to or greater than max, consider the joint static\n\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      } // calculate middle position\n\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName\n      };\n      const array = parseFloats(xml.textContent);\n\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n\n      return data;\n    } // physics\n\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    } // scene\n\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substr(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i]; // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n\n        if (targetElement) {\n          // get the parent of the transform element\n          const parentVisualElement = targetElement.parentElement; // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name');\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + \" doesn't exist.\");\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n\n          if (jointData) {\n            const joint = jointData.joint;\n\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity(); // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i]; // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector;\n\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            const matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n\n      return transforms;\n    } // nodes\n\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node'); // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'translate':\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'scale':\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n\n          case 'extra':\n            break;\n\n          default:\n            console.log(child);\n        }\n      }\n\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n\n      return data;\n    }\n\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material');\n\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute('symbol');\n              const target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n\n            break;\n\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n        }\n      }\n\n      return data;\n    }\n\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data; // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j];\n\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      } // sort bone data (the order is defined in the corresponding controller)\n\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      } // add unprocessed bone data at the end of the list\n\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      } // setup arrays for skeleton creation\n\n\n      const bones = [];\n      const boneInverses = [];\n\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n\n      return new Skeleton(bones, boneInverses);\n    }\n\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse; // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n            boneInverse = new Matrix4();\n          }\n\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n\n    function buildNode(data) {\n      const objects = [];\n      const matrix = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes; // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      } // instance cameras\n\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      } // instance controllers\n\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j];\n\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n\n          objects.push(object);\n        }\n      } // instance lights\n\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      } // instance geometries\n\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i]; // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      } // instance nodes\n\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n\n      let object;\n\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n\n      return materials;\n    }\n\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials); // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        } // regard skinning\n\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined; // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials; // now create a specific 3D object\n\n        let object;\n\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n\n            break;\n        }\n\n        objects.push(object);\n      }\n\n      return objects;\n    }\n\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    } // visual scenes\n\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      const elements = getElementsByTagName(xml, 'node');\n\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n\n      return group;\n    }\n\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    } // scenes\n\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n\n    function setupAnimations() {\n      const clips = library.clips;\n\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n          const tracks = [];\n\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    } // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n\n    function parserErrorToText(parserError) {\n      let result = '';\n      const stack = [parserError];\n\n      while (stack.length) {\n        const node = stack.shift();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n\n      return result.trim();\n    }\n\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n\n    const xml = new DOMParser().parseFromString(text, 'application/xml');\n    const collada = getElementsByTagName(xml, 'COLLADA')[0];\n    const parserError = xml.getElementsByTagName('parsererror')[0];\n\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n      const errorElement = getElementsByTagName(parserError, 'div')[0];\n      let errorText;\n\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    } // metadata\n\n\n    const version = collada.getAttribute('version');\n    console.log('THREE.ColladaLoader: File version', version);\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    } //\n\n\n    const animations = [];\n    let kinematics = {};\n    let count = 0; //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n\n    if (asset.upAxis === 'Z_UP') {\n      scene.quaternion.setFromEuler(new Euler(-Math.PI / 2, 0, 0));\n    }\n\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n\n}\n\nexport { ColladaLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from \"/home/odin/Desktop/THP\\u2620/Developpeur/Final_Project/pokeland/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/home/odin/Desktop/THP\\u2620/Developpeur/Final_Project/pokeland/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/odin/Desktop/THP\\u2620/Developpeur/Final_Project/pokeland/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { createContext, useState, useEffect, useRef, createElement, useContext, useCallback, useReducer, useDebugValue } from 'react';\nvar SUSPENSE_PROMISE = Symbol();\n\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\n\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\n\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _a, _b;\n\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\n\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\n\nvar createSuspensePromise = function createSuspensePromise(promise) {\n  var objectToAttach = {\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    objectToAttach.c = function () {\n      objectToAttach.c = null;\n      resolve();\n    };\n\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return \"init\" in atom;\n};\n\nvar READ_ATOM = \"r\";\nvar WRITE_ATOM = \"w\";\nvar COMMIT_ATOM = \"c\";\nvar SUBSCRIBE_ATOM = \"s\";\nvar RESTORE_ATOMS = \"h\";\nvar DEV_SUBSCRIBE_STATE = \"n\";\nvar DEV_GET_MOUNTED_ATOMS = \"l\";\nvar DEV_GET_ATOM_STATE = \"a\";\nvar DEV_GET_MOUNTED = \"m\";\n\nvar createStore = function createStore(initialValues) {\n  var _ref6;\n\n  var committedAtomStateMap = /* @__PURE__ */new WeakMap();\n  var mountedMap = /* @__PURE__ */new WeakMap();\n  var pendingMap = /* @__PURE__ */new Map();\n  var stateListeners;\n  var mountedAtoms;\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n\n  if (initialValues) {\n    var _iterator2 = _createForOfIteratorHelper(initialValues),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _step2$value = _slicedToArray(_step2.value, 2),\n            _atom2 = _step2$value[0],\n            value = _step2$value[1];\n\n        var atomState = {\n          v: value,\n          r: 0,\n          d: /* @__PURE__ */new Map()\n        };\n\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          Object.freeze(atomState);\n\n          if (!hasInitialValue(_atom2)) {\n            console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", _atom2);\n          }\n        }\n\n        committedAtomStateMap.set(_atom2, atomState);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  var suspensePromiseCacheMap = /* @__PURE__ */new WeakMap();\n\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (!cache) {\n      cache = /* @__PURE__ */new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = /* @__PURE__ */new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n\n    return versionSet;\n  };\n\n  var versionedAtomStateMapMap = /* @__PURE__ */new WeakMap();\n\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n\n    return versionedAtomStateMap;\n  };\n\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n\n      var _atomState = versionedAtomStateMap.get(atom);\n\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n\n        if (_atomState) {\n          if (\"p\" in _atomState) {\n            _atomState.p.then(function () {\n              return versionedAtomStateMap.delete(atom);\n            });\n          }\n\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n\n      return _atomState;\n    }\n\n    return committedAtomStateMap.get(atom);\n  };\n\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n\n  var createReadDependencies = function createReadDependencies(version) {\n    var prevReadDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();\n    var dependencies = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n\n    var readDependencies = /* @__PURE__ */new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _a;\n\n      var revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n\n    return readDependencies;\n  };\n\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    var changed = false;\n\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(function (a) {\n      return atomState.d.has(a);\n    }))) {\n      changed = true;\n      Promise.resolve().then(function () {\n        flushPending(version);\n      });\n    }\n\n    if (atomState && !changed) {\n      return atomState;\n    }\n\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    var nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n\n      cancelSuspensePromise(atomState.p);\n    }\n\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(function () {\n              readAtomState(version, atom, true);\n            });\n          }\n\n          return e;\n        }\n\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      var nextAtomState = __spreadProps(__spreadValues({}, atomState), {\n        i: atomState.r\n      });\n\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n\n      if (_atomState2) {\n        if (_atomState2.r !== _atomState2.i && \"p\" in _atomState2 && !isSuspensePromiseAlreadyCancelled(_atomState2.p)) {\n          return _atomState2;\n        }\n\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n\n        if (Array.from(_atomState2.d).every(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              a = _ref2[0],\n              r = _ref2[1];\n\n          var aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return _atomState2;\n        }\n      }\n    }\n\n    var dependencies = /* @__PURE__ */new Set();\n\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n\n  var addAtom = function addAtom(addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n\n  var delAtom = function delAtom(deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n\n    var writeGetter = function writeGetter(a, options) {\n      var aState = readAtomState(version, a);\n\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(function () {\n            return writeGetter(a, options);\n          });\n        }\n\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n\n        throw aState.p;\n      }\n\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n\n      throw new Error(\"no value found\");\n    };\n\n    var setter = function setter(a, v) {\n      var promiseOrVoid2;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        var prevAtomState = getAtomState(version, a);\n        var nextAtomState = setAtomPromiseOrValue(version, a, v);\n\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n\n      if (!isSync) {\n        flushPending(version);\n      }\n\n      return promiseOrVoid2;\n    };\n\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = void 0;\n    return promiseOrVoid;\n  };\n\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n\n    var atomState = readAtomState(void 0, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update);\n      };\n\n      var onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  var unmountAtom = function unmountAtom(atom) {\n    var _a;\n\n    var onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n\n    var atomState = getAtomState(void 0, atom);\n\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.t.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n\n  var mountDependencies = function mountDependencies(atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        var committedAtomState = committedAtomStateMap.get(atom);\n\n        if (atomState !== committedAtomState) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            atom = _ref4[0],\n            prevAtomState = _ref4[1];\n\n        var atomState = getAtomState(void 0, atom);\n\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n\n        if (prevAtomState && \"i\" in prevAtomState && atomState && !(\"i\" in atomState)) {\n          return;\n        }\n\n        var mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n          return listener();\n        });\n      });\n    }\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || \"v\" in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n\n    flushPending(void 0);\n  };\n\n  var subscribeAtom = function subscribeAtom(atom, callback) {\n    var mounted = addAtom(atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  var restoreAtoms = function restoreAtoms(values, version) {\n    var _iterator3 = _createForOfIteratorHelper(values),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n            _atom3 = _step3$value[0],\n            _value = _step3$value[1];\n\n        if (hasInitialValue(_atom3)) {\n          setAtomPromiseOrValue(version, _atom3, _value);\n          invalidateDependents(version, _atom3);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    flushPending(version);\n  };\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    var _ref5;\n\n    return _ref5 = {}, _defineProperty(_ref5, READ_ATOM, readAtom), _defineProperty(_ref5, WRITE_ATOM, writeAtom), _defineProperty(_ref5, COMMIT_ATOM, commitAtom), _defineProperty(_ref5, SUBSCRIBE_ATOM, subscribeAtom), _defineProperty(_ref5, RESTORE_ATOMS, restoreAtoms), _defineProperty(_ref5, DEV_SUBSCRIBE_STATE, function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }), _defineProperty(_ref5, DEV_GET_MOUNTED_ATOMS, function () {\n      return mountedAtoms.values();\n    }), _defineProperty(_ref5, DEV_GET_ATOM_STATE, function (a) {\n      return committedAtomStateMap.get(a);\n    }), _defineProperty(_ref5, DEV_GET_MOUNTED, function (a) {\n      return mountedMap.get(a);\n    }), _ref5;\n  }\n\n  return _ref6 = {}, _defineProperty(_ref6, READ_ATOM, readAtom), _defineProperty(_ref6, WRITE_ATOM, writeAtom), _defineProperty(_ref6, COMMIT_ATOM, commitAtom), _defineProperty(_ref6, SUBSCRIBE_ATOM, subscribeAtom), _defineProperty(_ref6, RESTORE_ATOMS, restoreAtoms), _ref6;\n};\n\nvar createStoreForExport = function createStoreForExport(initialValues) {\n  var store = createStore(initialValues);\n\n  var get = function get(atom) {\n    var atomState = store[READ_ATOM](atom);\n\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n\n    return atomState.v;\n  };\n\n  var asyncGet = function asyncGet(atom) {\n    return new Promise(function (resolve, reject) {\n      var atomState = store[READ_ATOM](atom);\n\n      if (\"e\" in atomState) {\n        reject(atomState.e);\n      } else if (\"p\" in atomState) {\n        resolve(atomState.p.then(function () {\n          return asyncGet(atom);\n        }));\n      } else {\n        resolve(atomState.v);\n      }\n    });\n  };\n\n  var set = function set(atom, update) {\n    return store[WRITE_ATOM](atom, update);\n  };\n\n  var sub = function sub(atom, callback) {\n    return store[SUBSCRIBE_ATOM](atom, callback);\n  };\n\n  return {\n    get: get,\n    asyncGet: asyncGet,\n    set: set,\n    sub: sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues, unstable_createStore) {\n  var store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\n\nvar ScopeContextMap = /* @__PURE__ */new Map();\n\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref7) {\n  var children = _ref7.children,\n      initialValues = _ref7.initialValues,\n      scope = _ref7.scope,\n      unstable_createStore = _ref7.unstable_createStore,\n      unstable_enableVersionedWrite = _ref7.unstable_enableVersionedWrite;\n\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      version = _useState2[0],\n      setVersion = _useState2[1];\n\n  useEffect(function () {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  var scopeContainerRef = useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues, unstable_createStore);\n\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = parentVersion ? {\n            p: parentVersion\n          } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n\n  var ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nvar keyCount = 0;\n\nfunction atom(read, write) {\n  var key = \"atom\".concat(++keyCount);\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = function (get) {\n      return get(config);\n    };\n\n    config.write = function (get, set, update) {\n      return set(config, typeof update === \"function\" ? update(get(config)) : update);\n    };\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext = useContext(ScopeContext),\n      store = _useContext.s;\n\n  var getAtomValue = useCallback(function (version2) {\n    var atomState = store[READ_ATOM](atom, version2);\n\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error(\"no atom value\");\n  }, [store, atom]);\n\n  var _useReducer = useReducer(useCallback(function (prev, nextVersion) {\n    var nextValue = getAtomValue(nextVersion);\n\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), void 0, function () {\n    var initialVersion = void 0;\n    var initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  }),\n      _useReducer2 = _slicedToArray(_useReducer, 2),\n      _useReducer2$ = _slicedToArray(_useReducer2[0], 3),\n      version = _useReducer2$[0],\n      value = _useReducer2$[1],\n      atomFromUseReducer = _useReducer2$[2],\n      rerenderIfChanged = _useReducer2[1];\n\n  if (atomFromUseReducer !== atom) {\n    rerenderIfChanged(void 0);\n  }\n\n  useEffect(function () {\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged);\n    rerenderIfChanged(void 0);\n    return unsubscribe;\n  }, [store, atom]);\n  useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n\n  var _useContext2 = useContext(ScopeContext),\n      store = _useContext2.s,\n      versionedWrite = _useContext2.w;\n\n  var setAtom = useCallback(function (update) {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n\n    var write = function write(version) {\n      return store[WRITE_ATOM](atom, update, version);\n    };\n\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n\n  return [useAtomValue(atom, scope), useSetAtom(atom, scope)];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };","map":{"version":3,"names":["createContext","useState","useEffect","useRef","createElement","useContext","useCallback","useReducer","useDebugValue","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_a","_b","call","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","then","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","__spreadProps","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","committedAtomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","atomState","v","r","d","freeze","console","warn","set","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","get","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","is","Array","from","keys","every","flushPending","setAtomReadError","error","e","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","setAtomInvalidated","i","force","_","aState","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","info","setter","promiseOrVoid2","cancelledVersion","promiseOrVoid","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","mountDependencies","committedAtomState","listener","pending","clear","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","createStoreForExport","store","asyncGet","reject","sub","SECRET_INTERNAL_store","createScopeContainer","unstable_createStore","s","ScopeContextMap","getScopeContext","scope","Provider","children","unstable_enableVersionedWrite","setVersion","scopeContainerRef","current","w","parentVersion","nextVersion","ScopeContainerContext","keyCount","config","toString","useAtomValue","ScopeContext","getAtomValue","version2","prev","nextValue","initialVersion","initialValue","atomFromUseReducer","rerenderIfChanged","unsubscribe","useSetAtom","versionedWrite","useAtom","SECRET_INTERNAL_getScopeContext"],"sources":["/home/odin/Desktop/THPâ˜ /Developpeur/Final_Project/pokeland/node_modules/jotai/esm/index.js"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useCallback, useReducer, useDebugValue } from 'react';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a, _b;\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (promise) => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = { v: value, r: 0, d: /* @__PURE__ */ new Map() };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState) {\n          if (\"p\" in atomState) {\n            atomState.p.then(() => versionedAtomStateMap.delete(atom));\n          }\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = false;\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(promiseOrValue.then((value) => {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch((e) => {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(() => {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = __spreadProps(__spreadValues({}, atomState), {\n        i: atomState.r\n      });\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.r !== atomState.i && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => writeGetter(a, options));\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = void 0;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update);\n      const onUnmount = atom.onMount(setAtom);\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(void 0, atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && \"i\" in prevAtomState && atomState && !(\"i\" in atomState)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || \"v\" in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback) => {\n    const mounted = addAtom(atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = parentVersion ? { p: parentVersion } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store } = useContext(ScopeContext);\n  const getAtomValue = useCallback((version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  }, [store, atom]);\n  const [[version, value, atomFromUseReducer], rerenderIfChanged] = useReducer(useCallback((prev, nextVersion) => {\n    const nextValue = getAtomValue(nextVersion);\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), void 0, () => {\n    const initialVersion = void 0;\n    const initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  });\n  if (atomFromUseReducer !== atom) {\n    rerenderIfChanged(void 0);\n  }\n  useEffect(() => {\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged);\n    rerenderIfChanged(void 0);\n    return unsubscribe;\n  }, [store, atom]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback((update) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    const write = (version) => store[WRITE_ATOM](atom, update, version);\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
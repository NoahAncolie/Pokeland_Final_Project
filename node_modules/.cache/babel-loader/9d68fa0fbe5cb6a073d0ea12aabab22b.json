{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\n\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor() {\n    let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", new Color(0x000000));\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          const colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };","map":{"version":3,"names":["_defineProperty","Vector2","ShaderLib","UniformsUtils","UniformsLib","ShaderMaterial","Color","LineUniforms","linewidth","value","resolution","dashScale","dashSize","dashOffset","gapSize","opacity","uniforms","merge","common","fog","vertexShader","fragmentShader","LineMaterial","constructor","parameters","clone","clipping","Object","defineProperties","color","enumerable","get","diffuse","set","colorObj","getHex","copy","alphaToCoverage","Boolean","defines","needsUpdate","ALPHA_TO_COVERAGE","extensions","derivatives","dashed","USE_DASH","setValues"],"sources":["/Users/paolucciloic/Desktop/pokemon-projet-final/Pokeland_Final_Project/node_modules/three-stdlib/lines/LineMaterial.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Vector2, ShaderLib, UniformsUtils, UniformsLib, ShaderMaterial, Color } from 'three';\n\n/**\n * parameters = {\n *  color: <hex>,\n *  linewidth: <float>,\n *  dashed: <boolean>,\n *  dashScale: <float>,\n *  dashSize: <float>,\n *  dashOffset: <float>,\n *  gapSize: <float>,\n *  resolution: <Vector2>, // to be set by renderer\n * }\n */\nconst LineUniforms = {\n  linewidth: {\n    value: 1\n  },\n  resolution: {\n    value: new Vector2(1, 1)\n  },\n  dashScale: {\n    value: 1\n  },\n  dashSize: {\n    value: 1\n  },\n  dashOffset: {\n    value: 0\n  },\n  gapSize: {\n    value: 1\n  },\n  // todo FIX - maybe change to totalSize\n  opacity: {\n    value: 1\n  }\n};\nShaderLib['line'] = {\n  uniforms: UniformsUtils.merge([UniformsLib.common, UniformsLib.fog, LineUniforms]),\n  vertexShader:\n  /* glsl */\n  `\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t`,\n  fragmentShader:\n  /* glsl */\n  `\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tfloat alpha = opacity;\n\n\t\t\t#ifdef ALPHA_TO_COVERAGE\n\n\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\n\t\t\tfloat a = vUv.x;\n\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\tfloat len2 = a * a + b * b;\n\t\t\tfloat dlen = fwidth( len2 );\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\n\n\t\t\t}\n\n\t\t\t#else\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\t#endif\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t`\n};\n\nclass LineMaterial extends ShaderMaterial {\n  constructor(parameters = {}) {\n    super({\n      uniforms: UniformsUtils.clone(ShaderLib['line'].uniforms),\n      vertexShader: ShaderLib['line'].vertexShader,\n      fragmentShader: ShaderLib['line'].fragmentShader,\n      clipping: true // required for clipping support\n\n    });\n    /**\n     * Everytime I remove this, everything just breaks,\n     * so I'm just gonna leave it here.\n     */\n\n    _defineProperty(this, \"isLineMaterial\", true);\n\n    _defineProperty(this, \"dashed\", false);\n\n    _defineProperty(this, \"color\", new Color(0x000000));\n\n    _defineProperty(this, \"lineWidth\", 0);\n\n    _defineProperty(this, \"dashScale\", 0);\n\n    _defineProperty(this, \"dashOffset\", 0);\n\n    _defineProperty(this, \"dashSize\", 0);\n\n    _defineProperty(this, \"opacity\", 0);\n\n    _defineProperty(this, \"resolution\", new Vector2());\n\n    _defineProperty(this, \"alphaToCoverage\", false);\n\n    Object.defineProperties(this, {\n      color: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.diffuse.value;\n        },\n        set: function (value) {\n          const colorObj = new Color(value);\n          this.uniforms.diffuse.value = colorObj.getHex();\n        }\n      },\n      linewidth: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.linewidth.value;\n        },\n        set: function (value) {\n          this.uniforms.linewidth.value = value;\n        }\n      },\n      dashScale: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashScale.value;\n        },\n        set: function (value) {\n          this.uniforms.dashScale.value = value;\n        }\n      },\n      dashSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashSize.value;\n        },\n        set: function (value) {\n          this.uniforms.dashSize.value = value;\n        }\n      },\n      dashOffset: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.dashOffset.value;\n        },\n        set: function (value) {\n          this.uniforms.dashOffset.value = value;\n        }\n      },\n      gapSize: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.gapSize.value;\n        },\n        set: function (value) {\n          this.uniforms.gapSize.value = value;\n        }\n      },\n      opacity: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.opacity.value;\n        },\n        set: function (value) {\n          this.uniforms.opacity.value = value;\n        }\n      },\n      resolution: {\n        enumerable: true,\n        get: function () {\n          return this.uniforms.resolution.value;\n        },\n        set: function (value) {\n          this.uniforms.resolution.value.copy(value);\n        }\n      },\n      alphaToCoverage: {\n        enumerable: true,\n        get: function () {\n          return Boolean('ALPHA_TO_COVERAGE' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('ALPHA_TO_COVERAGE' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.ALPHA_TO_COVERAGE = '';\n            this.extensions.derivatives = true;\n          } else {\n            delete this.defines.ALPHA_TO_COVERAGE;\n            this.extensions.derivatives = false;\n          }\n        }\n      },\n      dashed: {\n        enumerable: true,\n        get: function () {\n          return Boolean('USE_DASH' in this.defines);\n        },\n        set: function (value) {\n          if (Boolean(value) !== Boolean('USE_DASH' in this.defines)) {\n            this.needsUpdate = true;\n          }\n\n          if (value) {\n            this.defines.USE_DASH = '';\n          } else {\n            delete this.defines.USE_DASH;\n          }\n        }\n      }\n    });\n    this.setValues(parameters);\n  }\n\n}\n\nexport { LineMaterial };\n"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,2CAA5B;AACA,SAASC,OAAT,EAAkBC,SAAlB,EAA6BC,aAA7B,EAA4CC,WAA5C,EAAyDC,cAAzD,EAAyEC,KAAzE,QAAsF,OAAtF;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,YAAY,GAAG;EACnBC,SAAS,EAAE;IACTC,KAAK,EAAE;EADE,CADQ;EAInBC,UAAU,EAAE;IACVD,KAAK,EAAE,IAAIR,OAAJ,CAAY,CAAZ,EAAe,CAAf;EADG,CAJO;EAOnBU,SAAS,EAAE;IACTF,KAAK,EAAE;EADE,CAPQ;EAUnBG,QAAQ,EAAE;IACRH,KAAK,EAAE;EADC,CAVS;EAanBI,UAAU,EAAE;IACVJ,KAAK,EAAE;EADG,CAbO;EAgBnBK,OAAO,EAAE;IACPL,KAAK,EAAE;EADA,CAhBU;EAmBnB;EACAM,OAAO,EAAE;IACPN,KAAK,EAAE;EADA;AApBU,CAArB;AAwBAP,SAAS,CAAC,MAAD,CAAT,GAAoB;EAClBc,QAAQ,EAAEb,aAAa,CAACc,KAAd,CAAoB,CAACb,WAAW,CAACc,MAAb,EAAqBd,WAAW,CAACe,GAAjC,EAAsCZ,YAAtC,CAApB,CADQ;EAElBa,YAAY;EACZ;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GApJoB;EAqJlBC,cAAc;EACd;EACC;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApOoB,CAApB;;AAuOA,MAAMC,YAAN,SAA2BjB,cAA3B,CAA0C;EACxCkB,WAAW,GAAkB;IAAA,IAAjBC,UAAiB,uEAAJ,EAAI;IAC3B,MAAM;MACJR,QAAQ,EAAEb,aAAa,CAACsB,KAAd,CAAoBvB,SAAS,CAAC,MAAD,CAAT,CAAkBc,QAAtC,CADN;MAEJI,YAAY,EAAElB,SAAS,CAAC,MAAD,CAAT,CAAkBkB,YAF5B;MAGJC,cAAc,EAAEnB,SAAS,CAAC,MAAD,CAAT,CAAkBmB,cAH9B;MAIJK,QAAQ,EAAE,IAJN,CAIW;;IAJX,CAAN;IAOA;AACJ;AACA;AACA;;IAEI1B,eAAe,CAAC,IAAD,EAAO,gBAAP,EAAyB,IAAzB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAjB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,OAAP,EAAgB,IAAIM,KAAJ,CAAU,QAAV,CAAhB,CAAf;;IAEAN,eAAe,CAAC,IAAD,EAAO,WAAP,EAAoB,CAApB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,WAAP,EAAoB,CAApB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,YAAP,EAAqB,CAArB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,UAAP,EAAmB,CAAnB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,SAAP,EAAkB,CAAlB,CAAf;;IAEAA,eAAe,CAAC,IAAD,EAAO,YAAP,EAAqB,IAAIC,OAAJ,EAArB,CAAf;;IAEAD,eAAe,CAAC,IAAD,EAAO,iBAAP,EAA0B,KAA1B,CAAf;;IAEA2B,MAAM,CAACC,gBAAP,CAAwB,IAAxB,EAA8B;MAC5BC,KAAK,EAAE;QACLC,UAAU,EAAE,IADP;QAELC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcgB,OAAd,CAAsBvB,KAA7B;QACD,CAJI;QAKLwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,MAAMyB,QAAQ,GAAG,IAAI5B,KAAJ,CAAUG,KAAV,CAAjB;UACA,KAAKO,QAAL,CAAcgB,OAAd,CAAsBvB,KAAtB,GAA8ByB,QAAQ,CAACC,MAAT,EAA9B;QACD;MARI,CADqB;MAW5B3B,SAAS,EAAE;QACTsB,UAAU,EAAE,IADH;QAETC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcR,SAAd,CAAwBC,KAA/B;QACD,CAJQ;QAKTwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcR,SAAd,CAAwBC,KAAxB,GAAgCA,KAAhC;QACD;MAPQ,CAXiB;MAoB5BE,SAAS,EAAE;QACTmB,UAAU,EAAE,IADH;QAETC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcL,SAAd,CAAwBF,KAA/B;QACD,CAJQ;QAKTwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcL,SAAd,CAAwBF,KAAxB,GAAgCA,KAAhC;QACD;MAPQ,CApBiB;MA6B5BG,QAAQ,EAAE;QACRkB,UAAU,EAAE,IADJ;QAERC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcJ,QAAd,CAAuBH,KAA9B;QACD,CAJO;QAKRwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcJ,QAAd,CAAuBH,KAAvB,GAA+BA,KAA/B;QACD;MAPO,CA7BkB;MAsC5BI,UAAU,EAAE;QACViB,UAAU,EAAE,IADF;QAEVC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcH,UAAd,CAAyBJ,KAAhC;QACD,CAJS;QAKVwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcH,UAAd,CAAyBJ,KAAzB,GAAiCA,KAAjC;QACD;MAPS,CAtCgB;MA+C5BK,OAAO,EAAE;QACPgB,UAAU,EAAE,IADL;QAEPC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcF,OAAd,CAAsBL,KAA7B;QACD,CAJM;QAKPwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcF,OAAd,CAAsBL,KAAtB,GAA8BA,KAA9B;QACD;MAPM,CA/CmB;MAwD5BM,OAAO,EAAE;QACPe,UAAU,EAAE,IADL;QAEPC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcD,OAAd,CAAsBN,KAA7B;QACD,CAJM;QAKPwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcD,OAAd,CAAsBN,KAAtB,GAA8BA,KAA9B;QACD;MAPM,CAxDmB;MAiE5BC,UAAU,EAAE;QACVoB,UAAU,EAAE,IADF;QAEVC,GAAG,EAAE,YAAY;UACf,OAAO,KAAKf,QAAL,CAAcN,UAAd,CAAyBD,KAAhC;QACD,CAJS;QAKVwB,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,KAAKO,QAAL,CAAcN,UAAd,CAAyBD,KAAzB,CAA+B2B,IAA/B,CAAoC3B,KAApC;QACD;MAPS,CAjEgB;MA0E5B4B,eAAe,EAAE;QACfP,UAAU,EAAE,IADG;QAEfC,GAAG,EAAE,YAAY;UACf,OAAOO,OAAO,CAAC,uBAAuB,KAAKC,OAA7B,CAAd;QACD,CAJc;QAKfN,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,IAAI6B,OAAO,CAAC7B,KAAD,CAAP,KAAmB6B,OAAO,CAAC,uBAAuB,KAAKC,OAA7B,CAA9B,EAAqE;YACnE,KAAKC,WAAL,GAAmB,IAAnB;UACD;;UAED,IAAI/B,KAAJ,EAAW;YACT,KAAK8B,OAAL,CAAaE,iBAAb,GAAiC,EAAjC;YACA,KAAKC,UAAL,CAAgBC,WAAhB,GAA8B,IAA9B;UACD,CAHD,MAGO;YACL,OAAO,KAAKJ,OAAL,CAAaE,iBAApB;YACA,KAAKC,UAAL,CAAgBC,WAAhB,GAA8B,KAA9B;UACD;QACF;MAjBc,CA1EW;MA6F5BC,MAAM,EAAE;QACNd,UAAU,EAAE,IADN;QAENC,GAAG,EAAE,YAAY;UACf,OAAOO,OAAO,CAAC,cAAc,KAAKC,OAApB,CAAd;QACD,CAJK;QAKNN,GAAG,EAAE,UAAUxB,KAAV,EAAiB;UACpB,IAAI6B,OAAO,CAAC7B,KAAD,CAAP,KAAmB6B,OAAO,CAAC,cAAc,KAAKC,OAApB,CAA9B,EAA4D;YAC1D,KAAKC,WAAL,GAAmB,IAAnB;UACD;;UAED,IAAI/B,KAAJ,EAAW;YACT,KAAK8B,OAAL,CAAaM,QAAb,GAAwB,EAAxB;UACD,CAFD,MAEO;YACL,OAAO,KAAKN,OAAL,CAAaM,QAApB;UACD;QACF;MAfK;IA7FoB,CAA9B;IA+GA,KAAKC,SAAL,CAAetB,UAAf;EACD;;AAlJuC;;AAsJ1C,SAASF,YAAT"},"metadata":{},"sourceType":"module"}
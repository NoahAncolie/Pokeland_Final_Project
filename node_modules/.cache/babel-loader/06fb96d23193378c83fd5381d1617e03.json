{"ast":null,"code":"import UniformNode from '../core/UniformNode.js';\nimport UVNode from './UVNode.js';\n\nclass TextureNode extends UniformNode {\n  constructor(value) {\n    let uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new UVNode();\n    let biasNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    super(value, 'vec4');\n    this.uvNode = uvNode;\n    this.biasNode = biasNode;\n  }\n\n  getUniformHash() {\n    return this.value.uuid;\n  }\n\n  getInputType() {\n    return 'texture';\n  }\n\n  generate(builder, output) {\n    const texture = this.value;\n\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n\n    const textureProperty = super.generate(builder, 'texture');\n\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        const uvSnippet = this.uvNode.build(builder, 'vec2');\n        const biasNode = this.biasNode;\n\n        if (biasNode !== null) {\n          const biasSnippet = biasNode.build(builder, 'float');\n          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);\n        } else {\n          snippet = builder.getTexture(textureProperty, uvSnippet);\n        }\n\n        nodeData.snippet = snippet;\n      }\n\n      return builder.format(snippet, 'vec4', output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n\n}\n\nTextureNode.prototype.isTextureNode = true;\nexport default TextureNode;","map":{"version":3,"names":["UniformNode","UVNode","TextureNode","constructor","value","uvNode","biasNode","getUniformHash","uuid","getInputType","generate","builder","output","texture","isTexture","Error","textureProperty","isReference","nodeData","getDataFromNode","snippet","undefined","uvSnippet","build","biasSnippet","getTextureBias","getTexture","format","serialize","data","toJSON","meta","deserialize","textures","prototype","isTextureNode"],"sources":["/home/odin/Desktop/THPâ˜ /Developpeur/Final_Project/pokeland/node_modules/three-stdlib/nodes/accessors/TextureNode.js"],"sourcesContent":["import UniformNode from '../core/UniformNode.js';\nimport UVNode from './UVNode.js';\n\nclass TextureNode extends UniformNode {\n  constructor(value, uvNode = new UVNode(), biasNode = null) {\n    super(value, 'vec4');\n    this.uvNode = uvNode;\n    this.biasNode = biasNode;\n  }\n\n  getUniformHash() {\n    return this.value.uuid;\n  }\n\n  getInputType() {\n    return 'texture';\n  }\n\n  generate(builder, output) {\n    const texture = this.value;\n\n    if (!texture || texture.isTexture !== true) {\n      throw new Error('TextureNode: Need a three.js texture.');\n    }\n\n    const textureProperty = super.generate(builder, 'texture');\n\n    if (output === 'sampler') {\n      return textureProperty + '_sampler';\n    } else if (builder.isReference(output)) {\n      return textureProperty;\n    } else {\n      const nodeData = builder.getDataFromNode(this);\n      let snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        const uvSnippet = this.uvNode.build(builder, 'vec2');\n        const biasNode = this.biasNode;\n\n        if (biasNode !== null) {\n          const biasSnippet = biasNode.build(builder, 'float');\n          snippet = builder.getTextureBias(textureProperty, uvSnippet, biasSnippet);\n        } else {\n          snippet = builder.getTexture(textureProperty, uvSnippet);\n        }\n\n        nodeData.snippet = snippet;\n      }\n\n      return builder.format(snippet, 'vec4', output);\n    }\n  }\n\n  serialize(data) {\n    super.serialize(data);\n    data.value = this.value.toJSON(data.meta).uuid;\n  }\n\n  deserialize(data) {\n    super.deserialize(data);\n    this.value = data.meta.textures[data.value];\n  }\n\n}\n\nTextureNode.prototype.isTextureNode = true;\n\nexport default TextureNode;\n"],"mappings":"AAAA,OAAOA,WAAP,MAAwB,wBAAxB;AACA,OAAOC,MAAP,MAAmB,aAAnB;;AAEA,MAAMC,WAAN,SAA0BF,WAA1B,CAAsC;EACpCG,WAAW,CAACC,KAAD,EAAgD;IAAA,IAAxCC,MAAwC,uEAA/B,IAAIJ,MAAJ,EAA+B;IAAA,IAAjBK,QAAiB,uEAAN,IAAM;IACzD,MAAMF,KAAN,EAAa,MAAb;IACA,KAAKC,MAAL,GAAcA,MAAd;IACA,KAAKC,QAAL,GAAgBA,QAAhB;EACD;;EAEDC,cAAc,GAAG;IACf,OAAO,KAAKH,KAAL,CAAWI,IAAlB;EACD;;EAEDC,YAAY,GAAG;IACb,OAAO,SAAP;EACD;;EAEDC,QAAQ,CAACC,OAAD,EAAUC,MAAV,EAAkB;IACxB,MAAMC,OAAO,GAAG,KAAKT,KAArB;;IAEA,IAAI,CAACS,OAAD,IAAYA,OAAO,CAACC,SAAR,KAAsB,IAAtC,EAA4C;MAC1C,MAAM,IAAIC,KAAJ,CAAU,uCAAV,CAAN;IACD;;IAED,MAAMC,eAAe,GAAG,MAAMN,QAAN,CAAeC,OAAf,EAAwB,SAAxB,CAAxB;;IAEA,IAAIC,MAAM,KAAK,SAAf,EAA0B;MACxB,OAAOI,eAAe,GAAG,UAAzB;IACD,CAFD,MAEO,IAAIL,OAAO,CAACM,WAAR,CAAoBL,MAApB,CAAJ,EAAiC;MACtC,OAAOI,eAAP;IACD,CAFM,MAEA;MACL,MAAME,QAAQ,GAAGP,OAAO,CAACQ,eAAR,CAAwB,IAAxB,CAAjB;MACA,IAAIC,OAAO,GAAGF,QAAQ,CAACE,OAAvB;;MAEA,IAAIA,OAAO,KAAKC,SAAhB,EAA2B;QACzB,MAAMC,SAAS,GAAG,KAAKjB,MAAL,CAAYkB,KAAZ,CAAkBZ,OAAlB,EAA2B,MAA3B,CAAlB;QACA,MAAML,QAAQ,GAAG,KAAKA,QAAtB;;QAEA,IAAIA,QAAQ,KAAK,IAAjB,EAAuB;UACrB,MAAMkB,WAAW,GAAGlB,QAAQ,CAACiB,KAAT,CAAeZ,OAAf,EAAwB,OAAxB,CAApB;UACAS,OAAO,GAAGT,OAAO,CAACc,cAAR,CAAuBT,eAAvB,EAAwCM,SAAxC,EAAmDE,WAAnD,CAAV;QACD,CAHD,MAGO;UACLJ,OAAO,GAAGT,OAAO,CAACe,UAAR,CAAmBV,eAAnB,EAAoCM,SAApC,CAAV;QACD;;QAEDJ,QAAQ,CAACE,OAAT,GAAmBA,OAAnB;MACD;;MAED,OAAOT,OAAO,CAACgB,MAAR,CAAeP,OAAf,EAAwB,MAAxB,EAAgCR,MAAhC,CAAP;IACD;EACF;;EAEDgB,SAAS,CAACC,IAAD,EAAO;IACd,MAAMD,SAAN,CAAgBC,IAAhB;IACAA,IAAI,CAACzB,KAAL,GAAa,KAAKA,KAAL,CAAW0B,MAAX,CAAkBD,IAAI,CAACE,IAAvB,EAA6BvB,IAA1C;EACD;;EAEDwB,WAAW,CAACH,IAAD,EAAO;IAChB,MAAMG,WAAN,CAAkBH,IAAlB;IACA,KAAKzB,KAAL,GAAayB,IAAI,CAACE,IAAL,CAAUE,QAAV,CAAmBJ,IAAI,CAACzB,KAAxB,CAAb;EACD;;AA1DmC;;AA8DtCF,WAAW,CAACgC,SAAZ,CAAsBC,aAAtB,GAAsC,IAAtC;AAEA,eAAejC,WAAf"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Loader, FileLoader, ShapePath } from 'three';\n\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== 'string') throw new Error('unsupported data type');\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n\n  parse(json) {\n    return new Font(json);\n  }\n\n}\n\nclass Font {\n  constructor(data) {\n    _defineProperty(this, \"data\", void 0);\n\n    this.data = data;\n  }\n\n  generateShapes(text) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    const shapes = [];\n    const paths = createPaths(text, size, this.data);\n\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n\n    return shapes;\n  }\n\n}\n\n_defineProperty(Font, \"isFont\", void 0);\n\n_defineProperty(Font, \"type\", void 0);\n\nfunction createPaths(text, size, data) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n      offsetY = 0;\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n\n      if (ret) {\n        offsetX += ret.offsetX;\n        paths.push(ret.path);\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs['?'];\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n\n      switch (action) {\n        case 'm':\n          // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n\n        case 'l':\n          // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n\n        case 'q':\n          // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n\n        case 'b':\n          // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\n\nexport { Font, FontLoader };","map":{"version":3,"names":["_defineProperty","Loader","FileLoader","ShapePath","FontLoader","constructor","manager","load","url","onLoad","onProgress","onError","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","response","Error","json","JSON","parse","font","Font","data","generateShapes","text","size","shapes","paths","createPaths","p","pl","length","Array","prototype","push","apply","toShapes","chars","from","scale","resolution","line_height","boundingBox","yMax","yMin","underlineThickness","offsetX","offsetY","i","char","ret","createPath","glyph","glyphs","console","error","familyName","x","y","cpx","cpy","cpx1","cpy1","cpx2","cpy2","o","outline","_cachedOutline","split","l","action","parseInt","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha"],"sources":["/Users/paolucciloic/Desktop/pokemon-projet-final/Pokeland_Final_Project/node_modules/three-stdlib/loaders/FontLoader.js"],"sourcesContent":["import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { Loader, FileLoader, ShapePath } from 'three';\n\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, response => {\n      if (typeof response !== 'string') throw new Error('unsupported data type');\n      const json = JSON.parse(response);\n      const font = this.parse(json);\n      if (onLoad) onLoad(font);\n    }, onProgress, onError);\n  }\n\n  parse(json) {\n    return new Font(json);\n  }\n\n}\nclass Font {\n  constructor(data) {\n    _defineProperty(this, \"data\", void 0);\n\n    this.data = data;\n  }\n\n  generateShapes(text, size = 100) {\n    const shapes = [];\n    const paths = createPaths(text, size, this.data);\n\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false));\n    }\n\n    return shapes;\n  }\n\n}\n\n_defineProperty(Font, \"isFont\", void 0);\n\n_defineProperty(Font, \"type\", void 0);\n\nfunction createPaths(text, size, data) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0,\n      offsetY = 0;\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n\n    if (char === '\\n') {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n\n      if (ret) {\n        offsetX += ret.offsetX;\n        paths.push(ret.path);\n      }\n    }\n  }\n\n  return paths;\n}\n\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs['?'];\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.');\n    return;\n  }\n\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '));\n\n    for (let i = 0, l = outline.length; i < l;) {\n      const action = outline[i++];\n\n      switch (action) {\n        case 'm':\n          // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n\n        case 'l':\n          // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX;\n          y = parseInt(outline[i++]) * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n\n        case 'q':\n          // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n\n        case 'b':\n          // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX;\n          cpy = parseInt(outline[i++]) * scale + offsetY;\n          cpx1 = parseInt(outline[i++]) * scale + offsetX;\n          cpy1 = parseInt(outline[i++]) * scale + offsetY;\n          cpx2 = parseInt(outline[i++]) * scale + offsetX;\n          cpy2 = parseInt(outline[i++]) * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n\n  return {\n    offsetX: glyph.ha * scale,\n    path\n  };\n}\n\nexport { Font, FontLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
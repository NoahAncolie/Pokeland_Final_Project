{"ast":null,"code":"import { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from 'three';\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n\n}\n\nclass XREstimatedLight extends Group {\n  constructor(renderer) {\n    let environmentEstimation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n\n}\n\nexport { XREstimatedLight };","map":{"version":3,"names":["Group","LightProbe","DirectionalLight","WebGLCubeRenderTarget","SessionLightProbe","constructor","xrLight","renderer","lightProbe","environmentEstimation","estimationStartCallback","xrWebGLBinding","frameCallback","onXRFrame","bind","session","xr","getSession","window","cubeRenderTarget","environment","texture","gl","getContext","preferredReflectionFormat","getExtension","XRWebGLBinding","addEventListener","updateReflection","requestAnimationFrame","textureProperties","properties","get","cubeMap","getReflectionCubeMap","__webglTexture","needsPMREMUpdate","time","xrFrame","lightEstimate","getLightEstimate","sh","fromArray","sphericalHarmonicsCoefficients","intensity","intensityScalar","Math","max","primaryLightIntensity","x","y","z","directionalLight","color","setRGB","position","copy","primaryLightDirection","dispose","XREstimatedLight","add","sessionLightProbe","estimationStarted","requestLightProbe","reflectionFormat","then","probe","dispatchEvent","type","remove"],"sources":["/home/odin/Desktop/THPâ˜ /Developpeur/Final_Project/pokeland/node_modules/three-stdlib/webxr/XREstimatedLight.js"],"sourcesContent":["import { Group, LightProbe, DirectionalLight, WebGLCubeRenderTarget } from 'three';\n\nclass SessionLightProbe {\n  constructor(xrLight, renderer, lightProbe, environmentEstimation, estimationStartCallback) {\n    this.xrLight = xrLight;\n    this.renderer = renderer;\n    this.lightProbe = lightProbe;\n    this.xrWebGLBinding = null;\n    this.estimationStartCallback = estimationStartCallback;\n    this.frameCallback = this.onXRFrame.bind(this);\n    const session = renderer.xr.getSession(); // If the XRWebGLBinding class is available then we can also query an\n    // estimated reflection cube map.\n\n    if (environmentEstimation && 'XRWebGLBinding' in window) {\n      // This is the simplest way I know of to initialize a WebGL cubemap in Three.\n      const cubeRenderTarget = new WebGLCubeRenderTarget(16);\n      xrLight.environment = cubeRenderTarget.texture;\n      const gl = renderer.getContext(); // Ensure that we have any extensions needed to use the preferred cube map format.\n\n      switch (session.preferredReflectionFormat) {\n        case 'srgba8':\n          gl.getExtension('EXT_sRGB');\n          break;\n\n        case 'rgba16f':\n          gl.getExtension('OES_texture_half_float');\n          break;\n      }\n\n      this.xrWebGLBinding = new XRWebGLBinding(session, gl);\n      this.lightProbe.addEventListener('reflectionchange', () => {\n        this.updateReflection();\n      });\n    } // Start monitoring the XR animation frame loop to look for lighting\n    // estimation changes.\n\n\n    session.requestAnimationFrame(this.frameCallback);\n  }\n\n  updateReflection() {\n    const textureProperties = this.renderer.properties.get(this.xrLight.environment);\n\n    if (textureProperties) {\n      const cubeMap = this.xrWebGLBinding.getReflectionCubeMap(this.lightProbe);\n\n      if (cubeMap) {\n        textureProperties.__webglTexture = cubeMap;\n        this.xrLight.environment.needsPMREMUpdate = true;\n      }\n    }\n  }\n\n  onXRFrame(time, xrFrame) {\n    // If either this obejct or the XREstimatedLight has been destroyed, stop\n    // running the frame loop.\n    if (!this.xrLight) {\n      return;\n    }\n\n    const session = xrFrame.session;\n    session.requestAnimationFrame(this.frameCallback);\n    const lightEstimate = xrFrame.getLightEstimate(this.lightProbe);\n\n    if (lightEstimate) {\n      // We can copy the estimate's spherical harmonics array directly into the light probe.\n      this.xrLight.lightProbe.sh.fromArray(lightEstimate.sphericalHarmonicsCoefficients);\n      this.xrLight.lightProbe.intensity = 1.0; // For the directional light we have to normalize the color and set the scalar as the\n      // intensity, since WebXR can return color values that exceed 1.0.\n\n      const intensityScalar = Math.max(1.0, Math.max(lightEstimate.primaryLightIntensity.x, Math.max(lightEstimate.primaryLightIntensity.y, lightEstimate.primaryLightIntensity.z)));\n      this.xrLight.directionalLight.color.setRGB(lightEstimate.primaryLightIntensity.x / intensityScalar, lightEstimate.primaryLightIntensity.y / intensityScalar, lightEstimate.primaryLightIntensity.z / intensityScalar);\n      this.xrLight.directionalLight.intensity = intensityScalar;\n      this.xrLight.directionalLight.position.copy(lightEstimate.primaryLightDirection);\n\n      if (this.estimationStartCallback) {\n        this.estimationStartCallback();\n        this.estimationStartCallback = null;\n      }\n    }\n  }\n\n  dispose() {\n    this.xrLight = null;\n    this.renderer = null;\n    this.lightProbe = null;\n    this.xrWebGLBinding = null;\n  }\n\n}\n\nclass XREstimatedLight extends Group {\n  constructor(renderer, environmentEstimation = true) {\n    super();\n    this.lightProbe = new LightProbe();\n    this.lightProbe.intensity = 0;\n    this.add(this.lightProbe);\n    this.directionalLight = new DirectionalLight();\n    this.directionalLight.intensity = 0;\n    this.add(this.directionalLight); // Will be set to a cube map in the SessionLightProbe is environment estimation is\n    // available and requested.\n\n    this.environment = null;\n    let sessionLightProbe = null;\n    let estimationStarted = false;\n    renderer.xr.addEventListener('sessionstart', () => {\n      const session = renderer.xr.getSession();\n\n      if ('requestLightProbe' in session) {\n        session.requestLightProbe({\n          reflectionFormat: session.preferredReflectionFormat\n        }).then(probe => {\n          sessionLightProbe = new SessionLightProbe(this, renderer, probe, environmentEstimation, () => {\n            estimationStarted = true; // Fired to indicate that the estimated lighting values are now being updated.\n\n            this.dispatchEvent({\n              type: 'estimationstart'\n            });\n          });\n        });\n      }\n    });\n    renderer.xr.addEventListener('sessionend', () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      if (estimationStarted) {\n        // Fired to indicate that the estimated lighting values are no longer being updated.\n        this.dispatchEvent({\n          type: 'estimationend'\n        });\n      }\n    }); // Done inline to provide access to sessionLightProbe.\n\n    this.dispose = () => {\n      if (sessionLightProbe) {\n        sessionLightProbe.dispose();\n        sessionLightProbe = null;\n      }\n\n      this.remove(this.lightProbe);\n      this.lightProbe = null;\n      this.remove(this.directionalLight);\n      this.directionalLight = null;\n      this.environment = null;\n    };\n  }\n\n}\n\nexport { XREstimatedLight };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
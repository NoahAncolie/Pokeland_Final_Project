{"ast":null,"code":"import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nconst boundingBox = /* @__PURE__ */new Box3();\n\nclass MeshBVHRootVisualizer extends Object3D {\n  get isMesh() {\n    return !this.displayEdges;\n  }\n\n  get isLineSegments() {\n    return this.displayEdges;\n  }\n\n  get isLine() {\n    return this.displayEdges;\n  }\n\n  constructor(mesh, material) {\n    let depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n    let group = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    super();\n    this.material = material;\n    this.geometry = new BufferGeometry();\n    this.name = 'MeshBVHRootVisualizer';\n    this.depth = depth;\n    this.displayParents = false;\n    this.mesh = mesh;\n    this.displayEdges = true;\n    this._group = group;\n  }\n\n  raycast() {}\n\n  update() {\n    const geometry = this.geometry;\n    const boundsTree = this.mesh.geometry.boundsTree;\n    const group = this._group;\n    geometry.dispose();\n    this.visible = false;\n\n    if (boundsTree) {\n      // count the number of bounds required\n      const targetDepth = this.depth - 1;\n      const displayParents = this.displayParents;\n      let boundsCount = 0;\n      boundsTree.traverse((depth, isLeaf) => {\n        if (depth === targetDepth || isLeaf) {\n          boundsCount++;\n          return true;\n        } else if (displayParents) {\n          boundsCount++;\n        }\n      }, group); // fill in the position buffer with the bounds corners\n\n      let posIndex = 0;\n      const positionArray = new Float32Array(8 * 3 * boundsCount);\n      boundsTree.traverse((depth, isLeaf, boundingData) => {\n        const terminate = depth === targetDepth || isLeaf;\n\n        if (terminate || displayParents) {\n          arrayToBox(0, boundingData, boundingBox);\n          const {\n            min,\n            max\n          } = boundingBox;\n\n          for (let x = -1; x <= 1; x += 2) {\n            const xVal = x < 0 ? min.x : max.x;\n\n            for (let y = -1; y <= 1; y += 2) {\n              const yVal = y < 0 ? min.y : max.y;\n\n              for (let z = -1; z <= 1; z += 2) {\n                const zVal = z < 0 ? min.z : max.z;\n                positionArray[posIndex + 0] = xVal;\n                positionArray[posIndex + 1] = yVal;\n                positionArray[posIndex + 2] = zVal;\n                posIndex += 3;\n              }\n            }\n          }\n\n          return terminate;\n        }\n      }, group);\n      let indexArray;\n      let indices;\n\n      if (this.displayEdges) {\n        // fill in the index buffer to point to the corner points\n        indices = new Uint8Array([// x axis\n        0, 4, 1, 5, 2, 6, 3, 7, // y axis\n        0, 2, 1, 3, 4, 6, 5, 7, // z axis\n        0, 1, 2, 3, 4, 5, 6, 7]);\n      } else {\n        indices = new Uint8Array([// X-, X+\n        0, 1, 2, 2, 1, 3, 4, 6, 5, 6, 7, 5, // Y-, Y+\n        1, 4, 5, 0, 4, 1, 2, 3, 6, 3, 7, 6, // Z-, Z+\n        0, 2, 4, 2, 6, 4, 1, 5, 3, 3, 5, 7]);\n      }\n\n      if (positionArray.length > 65535) {\n        indexArray = new Uint32Array(indices.length * boundsCount);\n      } else {\n        indexArray = new Uint16Array(indices.length * boundsCount);\n      }\n\n      const indexLength = indices.length;\n\n      for (let i = 0; i < boundsCount; i++) {\n        const posOffset = i * 8;\n        const indexOffset = i * indexLength;\n\n        for (let j = 0; j < indexLength; j++) {\n          indexArray[indexOffset + j] = posOffset + indices[j];\n        }\n      } // update the geometry\n\n\n      geometry.setIndex(new BufferAttribute(indexArray, 1, false));\n      geometry.setAttribute('position', new BufferAttribute(positionArray, 3, false));\n      this.visible = true;\n    }\n  }\n\n}\n\nclass MeshBVHVisualizer extends Group {\n  get color() {\n    return this.edgeMaterial.color;\n  }\n\n  get opacity() {\n    return this.edgeMaterial.opacity;\n  }\n\n  set opacity(v) {\n    this.edgeMaterial.opacity = v;\n    this.meshMaterial.opacity = v;\n  }\n\n  constructor(mesh) {\n    let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    super();\n    this.name = 'MeshBVHVisualizer';\n    this.depth = depth;\n    this.mesh = mesh;\n    this.displayParents = false;\n    this.displayEdges = true;\n    this._roots = [];\n    const edgeMaterial = new LineBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    const meshMaterial = new MeshBasicMaterial({\n      color: 0x00FF88,\n      transparent: true,\n      opacity: 0.3,\n      depthWrite: false\n    });\n    meshMaterial.color = edgeMaterial.color;\n    this.edgeMaterial = edgeMaterial;\n    this.meshMaterial = meshMaterial;\n    this.update();\n  }\n\n  update() {\n    const bvh = this.mesh.geometry.boundsTree;\n    const totalRoots = bvh ? bvh._roots.length : 0;\n\n    while (this._roots.length > totalRoots) {\n      const root = this._roots.pop();\n\n      root.geometry.dispose();\n      this.remove(root);\n    }\n\n    for (let i = 0; i < totalRoots; i++) {\n      if (i >= this._roots.length) {\n        const root = new MeshBVHRootVisualizer(this.mesh, this.edgeMaterial, this.depth, i);\n        this.add(root);\n\n        this._roots.push(root);\n      }\n\n      const root = this._roots[i];\n      root.depth = this.depth;\n      root.mesh = this.mesh;\n      root.displayParents = this.displayParents;\n      root.displayEdges = this.displayEdges;\n      root.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\n      root.update();\n    }\n  }\n\n  updateMatrixWorld() {\n    this.position.copy(this.mesh.position);\n    this.rotation.copy(this.mesh.rotation);\n    this.scale.copy(this.mesh.scale);\n    super.updateMatrixWorld(...arguments);\n  }\n\n  copy(source) {\n    this.depth = source.depth;\n    this.mesh = source.mesh;\n  }\n\n  clone() {\n    return new MeshBVHVisualizer(this.mesh, this.depth);\n  }\n\n  dispose() {\n    this.edgeMaterial.dispose();\n    this.meshMaterial.dispose();\n    const children = this.children;\n\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].geometry.dispose();\n    }\n  }\n\n}\n\nexport { MeshBVHVisualizer };","map":{"version":3,"names":["LineBasicMaterial","BufferAttribute","Box3","Group","MeshBasicMaterial","Object3D","BufferGeometry","arrayToBox","boundingBox","MeshBVHRootVisualizer","isMesh","displayEdges","isLineSegments","isLine","constructor","mesh","material","depth","group","geometry","name","displayParents","_group","raycast","update","boundsTree","dispose","visible","targetDepth","boundsCount","traverse","isLeaf","posIndex","positionArray","Float32Array","boundingData","terminate","min","max","x","xVal","y","yVal","z","zVal","indexArray","indices","Uint8Array","length","Uint32Array","Uint16Array","indexLength","i","posOffset","indexOffset","j","setIndex","setAttribute","MeshBVHVisualizer","color","edgeMaterial","opacity","v","meshMaterial","_roots","transparent","depthWrite","bvh","totalRoots","root","pop","remove","add","push","updateMatrixWorld","position","copy","rotation","scale","source","clone","children","l"],"sources":["/Users/paolucciloic/Desktop/pokemon-projet-final/Pokeland_Final_Project/node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js"],"sourcesContent":["import { LineBasicMaterial, BufferAttribute, Box3, Group, MeshBasicMaterial, Object3D, BufferGeometry } from 'three';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\n\r\nconst boundingBox = /* @__PURE__ */ new Box3();\r\nclass MeshBVHRootVisualizer extends Object3D {\r\n\r\n\tget isMesh() {\r\n\r\n\t\treturn ! this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLineSegments() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tget isLine() {\r\n\r\n\t\treturn this.displayEdges;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, material, depth = 10, group = 0 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.material = material;\r\n\t\tthis.geometry = new BufferGeometry();\r\n\t\tthis.name = 'MeshBVHRootVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._group = group;\r\n\r\n\t}\r\n\r\n\traycast() {}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst boundsTree = this.mesh.geometry.boundsTree;\r\n\t\tconst group = this._group;\r\n\t\tgeometry.dispose();\r\n\t\tthis.visible = false;\r\n\t\tif ( boundsTree ) {\r\n\r\n\t\t\t// count the number of bounds required\r\n\t\t\tconst targetDepth = this.depth - 1;\r\n\t\t\tconst displayParents = this.displayParents;\r\n\t\t\tlet boundsCount = 0;\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf ) => {\r\n\r\n\t\t\t\tif ( depth === targetDepth || isLeaf ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else if ( displayParents ) {\r\n\r\n\t\t\t\t\tboundsCount ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\t// fill in the position buffer with the bounds corners\r\n\t\t\tlet posIndex = 0;\r\n\t\t\tconst positionArray = new Float32Array( 8 * 3 * boundsCount );\r\n\t\t\tboundsTree.traverse( ( depth, isLeaf, boundingData ) => {\r\n\r\n\t\t\t\tconst terminate = depth === targetDepth || isLeaf;\r\n\t\t\t\tif ( terminate || displayParents ) {\r\n\r\n\t\t\t\t\tarrayToBox( 0, boundingData, boundingBox );\r\n\r\n\t\t\t\t\tconst { min, max } = boundingBox;\r\n\t\t\t\t\tfor ( let x = - 1; x <= 1; x += 2 ) {\r\n\r\n\t\t\t\t\t\tconst xVal = x < 0 ? min.x : max.x;\r\n\t\t\t\t\t\tfor ( let y = - 1; y <= 1; y += 2 ) {\r\n\r\n\t\t\t\t\t\t\tconst yVal = y < 0 ? min.y : max.y;\r\n\t\t\t\t\t\t\tfor ( let z = - 1; z <= 1; z += 2 ) {\r\n\r\n\t\t\t\t\t\t\t\tconst zVal = z < 0 ? min.z : max.z;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 0 ] = xVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 1 ] = yVal;\r\n\t\t\t\t\t\t\t\tpositionArray[ posIndex + 2 ] = zVal;\r\n\r\n\t\t\t\t\t\t\t\tposIndex += 3;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn terminate;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, group );\r\n\r\n\t\t\tlet indexArray;\r\n\t\t\tlet indices;\r\n\t\t\tif ( this.displayEdges ) {\r\n\r\n\t\t\t\t// fill in the index buffer to point to the corner points\r\n\t\t\t\tindices = new Uint8Array( [\r\n\t\t\t\t\t// x axis\r\n\t\t\t\t\t0, 4,\r\n\t\t\t\t\t1, 5,\r\n\t\t\t\t\t2, 6,\r\n\t\t\t\t\t3, 7,\r\n\r\n\t\t\t\t\t// y axis\r\n\t\t\t\t\t0, 2,\r\n\t\t\t\t\t1, 3,\r\n\t\t\t\t\t4, 6,\r\n\t\t\t\t\t5, 7,\r\n\r\n\t\t\t\t\t// z axis\r\n\t\t\t\t\t0, 1,\r\n\t\t\t\t\t2, 3,\r\n\t\t\t\t\t4, 5,\r\n\t\t\t\t\t6, 7,\r\n\t\t\t\t] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindices = new Uint8Array( [\r\n\r\n\t\t\t\t\t// X-, X+\r\n\t\t\t\t\t0, 1, 2,\r\n\t\t\t\t\t2, 1, 3,\r\n\r\n\t\t\t\t\t4, 6, 5,\r\n\t\t\t\t\t6, 7, 5,\r\n\r\n\t\t\t\t\t// Y-, Y+\r\n\t\t\t\t\t1, 4, 5,\r\n\t\t\t\t\t0, 4, 1,\r\n\r\n\t\t\t\t\t2, 3, 6,\r\n\t\t\t\t\t3, 7, 6,\r\n\r\n\t\t\t\t\t// Z-, Z+\r\n\t\t\t\t\t0, 2, 4,\r\n\t\t\t\t\t2, 6, 4,\r\n\r\n\t\t\t\t\t1, 5, 3,\r\n\t\t\t\t\t3, 5, 7,\r\n\r\n\t\t\t\t] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( positionArray.length > 65535 ) {\r\n\r\n\t\t\t\tindexArray = new Uint32Array( indices.length * boundsCount );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tindexArray = new Uint16Array( indices.length * boundsCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst indexLength = indices.length;\r\n\t\t\tfor ( let i = 0; i < boundsCount; i ++ ) {\r\n\r\n\t\t\t\tconst posOffset = i * 8;\r\n\t\t\t\tconst indexOffset = i * indexLength;\r\n\t\t\t\tfor ( let j = 0; j < indexLength; j ++ ) {\r\n\r\n\t\t\t\t\tindexArray[ indexOffset + j ] = posOffset + indices[ j ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update the geometry\r\n\t\t\tgeometry.setIndex(\r\n\t\t\t\tnew BufferAttribute( indexArray, 1, false ),\r\n\t\t\t);\r\n\t\t\tgeometry.setAttribute(\r\n\t\t\t\t'position',\r\n\t\t\t\tnew BufferAttribute( positionArray, 3, false ),\r\n\t\t\t);\r\n\t\t\tthis.visible = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nclass MeshBVHVisualizer extends Group {\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.edgeMaterial.color;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.edgeMaterial.opacity;\r\n\r\n\t}\r\n\r\n\tset opacity( v ) {\r\n\r\n\t\tthis.edgeMaterial.opacity = v;\r\n\t\tthis.meshMaterial.opacity = v;\r\n\r\n\t}\r\n\r\n\tconstructor( mesh, depth = 10 ) {\r\n\r\n\t\tsuper();\r\n\r\n\t\tthis.name = 'MeshBVHVisualizer';\r\n\t\tthis.depth = depth;\r\n\t\tthis.mesh = mesh;\r\n\t\tthis.displayParents = false;\r\n\t\tthis.displayEdges = true;\r\n\t\tthis._roots = [];\r\n\r\n\t\tconst edgeMaterial = new LineBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tconst meshMaterial = new MeshBasicMaterial( {\r\n\t\t\tcolor: 0x00FF88,\r\n\t\t\ttransparent: true,\r\n\t\t\topacity: 0.3,\r\n\t\t\tdepthWrite: false,\r\n\t\t} );\r\n\r\n\t\tmeshMaterial.color = edgeMaterial.color;\r\n\r\n\t\tthis.edgeMaterial = edgeMaterial;\r\n\t\tthis.meshMaterial = meshMaterial;\r\n\r\n\t\tthis.update();\r\n\r\n\t}\r\n\r\n\tupdate() {\r\n\r\n\t\tconst bvh = this.mesh.geometry.boundsTree;\r\n\t\tconst totalRoots = bvh ? bvh._roots.length : 0;\r\n\t\twhile ( this._roots.length > totalRoots ) {\r\n\r\n\t\t\tconst root = this._roots.pop();\r\n\t\t\troot.geometry.dispose();\r\n\t\t\tthis.remove( root );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( let i = 0; i < totalRoots; i ++ ) {\r\n\r\n\t\t\tif ( i >= this._roots.length ) {\r\n\r\n\t\t\t\tconst root = new MeshBVHRootVisualizer( this.mesh, this.edgeMaterial, this.depth, i );\r\n\t\t\t\tthis.add( root );\r\n\t\t\t\tthis._roots.push( root );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconst root = this._roots[ i ];\r\n\t\t\troot.depth = this.depth;\r\n\t\t\troot.mesh = this.mesh;\r\n\t\t\troot.displayParents = this.displayParents;\r\n\t\t\troot.displayEdges = this.displayEdges;\r\n\t\t\troot.material = this.displayEdges ? this.edgeMaterial : this.meshMaterial;\r\n\t\t\troot.update();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdateMatrixWorld( ...args ) {\r\n\r\n\t\tthis.position.copy( this.mesh.position );\r\n\t\tthis.rotation.copy( this.mesh.rotation );\r\n\t\tthis.scale.copy( this.mesh.scale );\r\n\r\n\t\tsuper.updateMatrixWorld( ...args );\r\n\r\n\t}\r\n\r\n\tcopy( source ) {\r\n\r\n\t\tthis.depth = source.depth;\r\n\t\tthis.mesh = source.mesh;\r\n\r\n\t}\r\n\r\n\tclone() {\r\n\r\n\t\treturn new MeshBVHVisualizer( this.mesh, this.depth );\r\n\r\n\t}\r\n\r\n\tdispose() {\r\n\r\n\t\tthis.edgeMaterial.dispose();\r\n\t\tthis.meshMaterial.dispose();\r\n\r\n\t\tconst children = this.children;\r\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].geometry.dispose();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\n\r\nexport { MeshBVHVisualizer };\r\n"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,eAA5B,EAA6CC,IAA7C,EAAmDC,KAAnD,EAA0DC,iBAA1D,EAA6EC,QAA7E,EAAuFC,cAAvF,QAA6G,OAA7G;AACA,SAASC,UAAT,QAA2B,+BAA3B;AAEA,MAAMC,WAAW,GAAG,eAAgB,IAAIN,IAAJ,EAApC;;AACA,MAAMO,qBAAN,SAAoCJ,QAApC,CAA6C;EAElC,IAANK,MAAM,GAAG;IAEZ,OAAO,CAAE,KAAKC,YAAd;EAEA;;EAEiB,IAAdC,cAAc,GAAG;IAEpB,OAAO,KAAKD,YAAZ;EAEA;;EAES,IAANE,MAAM,GAAG;IAEZ,OAAO,KAAKF,YAAZ;EAEA;;EAEDG,WAAW,CAAEC,IAAF,EAAQC,QAAR,EAA0C;IAAA,IAAxBC,KAAwB,uEAAhB,EAAgB;IAAA,IAAZC,KAAY,uEAAJ,CAAI;IAEpD;IAEA,KAAKF,QAAL,GAAgBA,QAAhB;IACA,KAAKG,QAAL,GAAgB,IAAIb,cAAJ,EAAhB;IACA,KAAKc,IAAL,GAAY,uBAAZ;IACA,KAAKH,KAAL,GAAaA,KAAb;IACA,KAAKI,cAAL,GAAsB,KAAtB;IACA,KAAKN,IAAL,GAAYA,IAAZ;IACA,KAAKJ,YAAL,GAAoB,IAApB;IACA,KAAKW,MAAL,GAAcJ,KAAd;EAEA;;EAEDK,OAAO,GAAG,CAAE;;EAEZC,MAAM,GAAG;IAER,MAAML,QAAQ,GAAG,KAAKA,QAAtB;IACA,MAAMM,UAAU,GAAG,KAAKV,IAAL,CAAUI,QAAV,CAAmBM,UAAtC;IACA,MAAMP,KAAK,GAAG,KAAKI,MAAnB;IACAH,QAAQ,CAACO,OAAT;IACA,KAAKC,OAAL,GAAe,KAAf;;IACA,IAAKF,UAAL,EAAkB;MAEjB;MACA,MAAMG,WAAW,GAAG,KAAKX,KAAL,GAAa,CAAjC;MACA,MAAMI,cAAc,GAAG,KAAKA,cAA5B;MACA,IAAIQ,WAAW,GAAG,CAAlB;MACAJ,UAAU,CAACK,QAAX,CAAqB,CAAEb,KAAF,EAASc,MAAT,KAAqB;QAEzC,IAAKd,KAAK,KAAKW,WAAV,IAAyBG,MAA9B,EAAuC;UAEtCF,WAAW;UACX,OAAO,IAAP;QAEA,CALD,MAKO,IAAKR,cAAL,EAAsB;UAE5BQ,WAAW;QAEX;MAED,CAbD,EAaGX,KAbH,EANiB,CAqBjB;;MACA,IAAIc,QAAQ,GAAG,CAAf;MACA,MAAMC,aAAa,GAAG,IAAIC,YAAJ,CAAkB,IAAI,CAAJ,GAAQL,WAA1B,CAAtB;MACAJ,UAAU,CAACK,QAAX,CAAqB,CAAEb,KAAF,EAASc,MAAT,EAAiBI,YAAjB,KAAmC;QAEvD,MAAMC,SAAS,GAAGnB,KAAK,KAAKW,WAAV,IAAyBG,MAA3C;;QACA,IAAKK,SAAS,IAAIf,cAAlB,EAAmC;UAElCd,UAAU,CAAE,CAAF,EAAK4B,YAAL,EAAmB3B,WAAnB,CAAV;UAEA,MAAM;YAAE6B,GAAF;YAAOC;UAAP,IAAe9B,WAArB;;UACA,KAAM,IAAI+B,CAAC,GAAG,CAAE,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2BA,CAAC,IAAI,CAAhC,EAAoC;YAEnC,MAAMC,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQF,GAAG,CAACE,CAAZ,GAAgBD,GAAG,CAACC,CAAjC;;YACA,KAAM,IAAIE,CAAC,GAAG,CAAE,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2BA,CAAC,IAAI,CAAhC,EAAoC;cAEnC,MAAMC,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQJ,GAAG,CAACI,CAAZ,GAAgBH,GAAG,CAACG,CAAjC;;cACA,KAAM,IAAIE,CAAC,GAAG,CAAE,CAAhB,EAAmBA,CAAC,IAAI,CAAxB,EAA2BA,CAAC,IAAI,CAAhC,EAAoC;gBAEnC,MAAMC,IAAI,GAAGD,CAAC,GAAG,CAAJ,GAAQN,GAAG,CAACM,CAAZ,GAAgBL,GAAG,CAACK,CAAjC;gBACAV,aAAa,CAAED,QAAQ,GAAG,CAAb,CAAb,GAAgCQ,IAAhC;gBACAP,aAAa,CAAED,QAAQ,GAAG,CAAb,CAAb,GAAgCU,IAAhC;gBACAT,aAAa,CAAED,QAAQ,GAAG,CAAb,CAAb,GAAgCY,IAAhC;gBAEAZ,QAAQ,IAAI,CAAZ;cAEA;YAED;UAED;;UAED,OAAOI,SAAP;QAEA;MAED,CAjCD,EAiCGlB,KAjCH;MAmCA,IAAI2B,UAAJ;MACA,IAAIC,OAAJ;;MACA,IAAK,KAAKnC,YAAV,EAAyB;QAExB;QACAmC,OAAO,GAAG,IAAIC,UAAJ,CAAgB,CACzB;QACA,CAFyB,EAEtB,CAFsB,EAGzB,CAHyB,EAGtB,CAHsB,EAIzB,CAJyB,EAItB,CAJsB,EAKzB,CALyB,EAKtB,CALsB,EAOzB;QACA,CARyB,EAQtB,CARsB,EASzB,CATyB,EAStB,CATsB,EAUzB,CAVyB,EAUtB,CAVsB,EAWzB,CAXyB,EAWtB,CAXsB,EAazB;QACA,CAdyB,EActB,CAdsB,EAezB,CAfyB,EAetB,CAfsB,EAgBzB,CAhByB,EAgBtB,CAhBsB,EAiBzB,CAjByB,EAiBtB,CAjBsB,CAAhB,CAAV;MAoBA,CAvBD,MAuBO;QAEND,OAAO,GAAG,IAAIC,UAAJ,CAAgB,CAEzB;QACA,CAHyB,EAGtB,CAHsB,EAGnB,CAHmB,EAIzB,CAJyB,EAItB,CAJsB,EAInB,CAJmB,EAMzB,CANyB,EAMtB,CANsB,EAMnB,CANmB,EAOzB,CAPyB,EAOtB,CAPsB,EAOnB,CAPmB,EASzB;QACA,CAVyB,EAUtB,CAVsB,EAUnB,CAVmB,EAWzB,CAXyB,EAWtB,CAXsB,EAWnB,CAXmB,EAazB,CAbyB,EAatB,CAbsB,EAanB,CAbmB,EAczB,CAdyB,EActB,CAdsB,EAcnB,CAdmB,EAgBzB;QACA,CAjByB,EAiBtB,CAjBsB,EAiBnB,CAjBmB,EAkBzB,CAlByB,EAkBtB,CAlBsB,EAkBnB,CAlBmB,EAoBzB,CApByB,EAoBtB,CApBsB,EAoBnB,CApBmB,EAqBzB,CArByB,EAqBtB,CArBsB,EAqBnB,CArBmB,CAAhB,CAAV;MAyBA;;MAED,IAAKd,aAAa,CAACe,MAAd,GAAuB,KAA5B,EAAoC;QAEnCH,UAAU,GAAG,IAAII,WAAJ,CAAiBH,OAAO,CAACE,MAAR,GAAiBnB,WAAlC,CAAb;MAEA,CAJD,MAIO;QAENgB,UAAU,GAAG,IAAIK,WAAJ,CAAiBJ,OAAO,CAACE,MAAR,GAAiBnB,WAAlC,CAAb;MAEA;;MAED,MAAMsB,WAAW,GAAGL,OAAO,CAACE,MAA5B;;MACA,KAAM,IAAII,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGvB,WAArB,EAAkCuB,CAAC,EAAnC,EAAyC;QAExC,MAAMC,SAAS,GAAGD,CAAC,GAAG,CAAtB;QACA,MAAME,WAAW,GAAGF,CAAC,GAAGD,WAAxB;;QACA,KAAM,IAAII,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGJ,WAArB,EAAkCI,CAAC,EAAnC,EAAyC;UAExCV,UAAU,CAAES,WAAW,GAAGC,CAAhB,CAAV,GAAgCF,SAAS,GAAGP,OAAO,CAAES,CAAF,CAAnD;QAEA;MAED,CAtIgB,CAwIjB;;;MACApC,QAAQ,CAACqC,QAAT,CACC,IAAIvD,eAAJ,CAAqB4C,UAArB,EAAiC,CAAjC,EAAoC,KAApC,CADD;MAGA1B,QAAQ,CAACsC,YAAT,CACC,UADD,EAEC,IAAIxD,eAAJ,CAAqBgC,aAArB,EAAoC,CAApC,EAAuC,KAAvC,CAFD;MAIA,KAAKN,OAAL,GAAe,IAAf;IAEA;EAED;;AAhM2C;;AAoM7C,MAAM+B,iBAAN,SAAgCvD,KAAhC,CAAsC;EAE5B,IAALwD,KAAK,GAAG;IAEX,OAAO,KAAKC,YAAL,CAAkBD,KAAzB;EAEA;;EAEU,IAAPE,OAAO,GAAG;IAEb,OAAO,KAAKD,YAAL,CAAkBC,OAAzB;EAEA;;EAEU,IAAPA,OAAO,CAAEC,CAAF,EAAM;IAEhB,KAAKF,YAAL,CAAkBC,OAAlB,GAA4BC,CAA5B;IACA,KAAKC,YAAL,CAAkBF,OAAlB,GAA4BC,CAA5B;EAEA;;EAEDhD,WAAW,CAAEC,IAAF,EAAqB;IAAA,IAAbE,KAAa,uEAAL,EAAK;IAE/B;IAEA,KAAKG,IAAL,GAAY,mBAAZ;IACA,KAAKH,KAAL,GAAaA,KAAb;IACA,KAAKF,IAAL,GAAYA,IAAZ;IACA,KAAKM,cAAL,GAAsB,KAAtB;IACA,KAAKV,YAAL,GAAoB,IAApB;IACA,KAAKqD,MAAL,GAAc,EAAd;IAEA,MAAMJ,YAAY,GAAG,IAAI5D,iBAAJ,CAAuB;MAC3C2D,KAAK,EAAE,QADoC;MAE3CM,WAAW,EAAE,IAF8B;MAG3CJ,OAAO,EAAE,GAHkC;MAI3CK,UAAU,EAAE;IAJ+B,CAAvB,CAArB;IAOA,MAAMH,YAAY,GAAG,IAAI3D,iBAAJ,CAAuB;MAC3CuD,KAAK,EAAE,QADoC;MAE3CM,WAAW,EAAE,IAF8B;MAG3CJ,OAAO,EAAE,GAHkC;MAI3CK,UAAU,EAAE;IAJ+B,CAAvB,CAArB;IAOAH,YAAY,CAACJ,KAAb,GAAqBC,YAAY,CAACD,KAAlC;IAEA,KAAKC,YAAL,GAAoBA,YAApB;IACA,KAAKG,YAAL,GAAoBA,YAApB;IAEA,KAAKvC,MAAL;EAEA;;EAEDA,MAAM,GAAG;IAER,MAAM2C,GAAG,GAAG,KAAKpD,IAAL,CAAUI,QAAV,CAAmBM,UAA/B;IACA,MAAM2C,UAAU,GAAGD,GAAG,GAAGA,GAAG,CAACH,MAAJ,CAAWhB,MAAd,GAAuB,CAA7C;;IACA,OAAQ,KAAKgB,MAAL,CAAYhB,MAAZ,GAAqBoB,UAA7B,EAA0C;MAEzC,MAAMC,IAAI,GAAG,KAAKL,MAAL,CAAYM,GAAZ,EAAb;;MACAD,IAAI,CAAClD,QAAL,CAAcO,OAAd;MACA,KAAK6C,MAAL,CAAaF,IAAb;IAEA;;IAED,KAAM,IAAIjB,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGgB,UAArB,EAAiChB,CAAC,EAAlC,EAAwC;MAEvC,IAAKA,CAAC,IAAI,KAAKY,MAAL,CAAYhB,MAAtB,EAA+B;QAE9B,MAAMqB,IAAI,GAAG,IAAI5D,qBAAJ,CAA2B,KAAKM,IAAhC,EAAsC,KAAK6C,YAA3C,EAAyD,KAAK3C,KAA9D,EAAqEmC,CAArE,CAAb;QACA,KAAKoB,GAAL,CAAUH,IAAV;;QACA,KAAKL,MAAL,CAAYS,IAAZ,CAAkBJ,IAAlB;MAEA;;MAED,MAAMA,IAAI,GAAG,KAAKL,MAAL,CAAaZ,CAAb,CAAb;MACAiB,IAAI,CAACpD,KAAL,GAAa,KAAKA,KAAlB;MACAoD,IAAI,CAACtD,IAAL,GAAY,KAAKA,IAAjB;MACAsD,IAAI,CAAChD,cAAL,GAAsB,KAAKA,cAA3B;MACAgD,IAAI,CAAC1D,YAAL,GAAoB,KAAKA,YAAzB;MACA0D,IAAI,CAACrD,QAAL,GAAgB,KAAKL,YAAL,GAAoB,KAAKiD,YAAzB,GAAwC,KAAKG,YAA7D;MACAM,IAAI,CAAC7C,MAAL;IAEA;EAED;;EAEDkD,iBAAiB,GAAY;IAE5B,KAAKC,QAAL,CAAcC,IAAd,CAAoB,KAAK7D,IAAL,CAAU4D,QAA9B;IACA,KAAKE,QAAL,CAAcD,IAAd,CAAoB,KAAK7D,IAAL,CAAU8D,QAA9B;IACA,KAAKC,KAAL,CAAWF,IAAX,CAAiB,KAAK7D,IAAL,CAAU+D,KAA3B;IAEA,MAAMJ,iBAAN,CAAyB,YAAzB;EAEA;;EAEDE,IAAI,CAAEG,MAAF,EAAW;IAEd,KAAK9D,KAAL,GAAa8D,MAAM,CAAC9D,KAApB;IACA,KAAKF,IAAL,GAAYgE,MAAM,CAAChE,IAAnB;EAEA;;EAEDiE,KAAK,GAAG;IAEP,OAAO,IAAItB,iBAAJ,CAAuB,KAAK3C,IAA5B,EAAkC,KAAKE,KAAvC,CAAP;EAEA;;EAEDS,OAAO,GAAG;IAET,KAAKkC,YAAL,CAAkBlC,OAAlB;IACA,KAAKqC,YAAL,CAAkBrC,OAAlB;IAEA,MAAMuD,QAAQ,GAAG,KAAKA,QAAtB;;IACA,KAAM,IAAI7B,CAAC,GAAG,CAAR,EAAW8B,CAAC,GAAGD,QAAQ,CAACjC,MAA9B,EAAsCI,CAAC,GAAG8B,CAA1C,EAA6C9B,CAAC,EAA9C,EAAoD;MAEnD6B,QAAQ,CAAE7B,CAAF,CAAR,CAAcjC,QAAd,CAAuBO,OAAvB;IAEA;EAED;;AA5HoC;;AAiItC,SAASgC,iBAAT"},"metadata":{},"sourceType":"module"}
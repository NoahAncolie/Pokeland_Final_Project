{"ast":null,"code":"import { createContext, useState, useEffect, useRef, createElement, useContext, useCallback, useReducer, useDebugValue } from 'react';\nconst SUSPENSE_PROMISE = Symbol();\n\nconst isSuspensePromise = promise => !!promise[SUSPENSE_PROMISE];\n\nconst isSuspensePromiseAlreadyCancelled = suspensePromise => !suspensePromise[SUSPENSE_PROMISE].c;\n\nconst cancelSuspensePromise = suspensePromise => {\n  var _a, _b;\n\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\n\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\n\nconst createSuspensePromise = promise => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise(resolve => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst hasInitialValue = atom => \"init\" in atom;\n\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\n\nconst createStore = initialValues => {\n  const committedAtomStateMap = /* @__PURE__ */new WeakMap();\n  const mountedMap = /* @__PURE__ */new WeakMap();\n  const pendingMap = /* @__PURE__ */new Map();\n  let stateListeners;\n  let mountedAtoms;\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */new Set();\n    mountedAtoms = /* @__PURE__ */new Set();\n  }\n\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = {\n        v: value,\n        r: 0,\n        d: /* @__PURE__ */new Map()\n      };\n\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n\n  const suspensePromiseCacheMap = /* @__PURE__ */new WeakMap();\n\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n\n    if (!cache) {\n      cache = /* @__PURE__ */new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n\n  const cancelAllSuspensePromiseInCache = atom => {\n    const versionSet = /* @__PURE__ */new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n\n    return versionSet;\n  };\n\n  const versionedAtomStateMapMap = /* @__PURE__ */new WeakMap();\n\n  const getVersionedAtomStateMap = version => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n\n    return versionedAtomStateMap;\n  };\n\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n\n        if (atomState) {\n          if (\"p\" in atomState) {\n            atomState.p.then(() => versionedAtomStateMap.delete(atom));\n          }\n\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n\n      return atomState;\n    }\n\n    return committedAtomStateMap.get(atom);\n  };\n\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n\n  const createReadDependencies = function (version) {\n    let prevReadDependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /* @__PURE__ */new Map();\n    let dependencies = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n\n    const readDependencies = /* @__PURE__ */new Map();\n    let changed = false;\n    dependencies.forEach(atom => {\n      var _a;\n\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n\n    return readDependencies;\n  };\n\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = false;\n\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(a => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n\n    if (atomState && !changed) {\n      return atomState;\n    }\n\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n\n    const nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n\n      cancelSuspensePromise(atomState.p);\n    }\n\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(promiseOrValue.then(value => {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(e => {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(() => {\n              readAtomState(version, atom, true);\n            });\n          }\n\n          return e;\n        }\n\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n\n    if (atomState) {\n      const nextAtomState = __spreadProps(__spreadValues({}, atomState), {\n        i: atomState.r\n      });\n\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n\n      if (atomState) {\n        if (atomState.r !== atomState.i && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n\n        if (Array.from(atomState.d).every(_ref => {\n          let [a, r] = _ref;\n          const aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return atomState;\n        }\n      }\n    }\n\n    const dependencies = /* @__PURE__ */new Set();\n\n    try {\n      const promiseOrValue = atom.read(a => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n\n          return aState.v;\n        }\n\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n\n  const addAtom = addingAtom => {\n    let mounted = mountedMap.get(addingAtom);\n\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n\n    return mounted;\n  };\n\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n\n  const delAtom = deletingAtom => {\n    const mounted = mountedMap.get(deletingAtom);\n\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(dependent => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => writeGetter(a, options));\n        }\n\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n\n        throw aState.p;\n      }\n\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n\n      throw new Error(\"no value found\");\n    };\n\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(cancelledVersion => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n\n      if (!isSync) {\n        flushPending(version);\n      }\n\n      return promiseOrVoid2;\n    };\n\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = void 0;\n    return promiseOrVoid;\n  };\n\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n\n  const isActuallyWritableAtom = atom => !!atom.write;\n\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */new Set()\n    };\n    mountedMap.set(atom, mounted);\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = update => writeAtom(atom, update);\n\n      const onUnmount = atom.onMount(setAtom);\n\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n\n    return mounted;\n  };\n\n  const unmountAtom = atom => {\n    var _a;\n\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n\n    if (onUnmount) {\n      onUnmount();\n    }\n\n    mountedMap.delete(atom);\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n\n    const atomState = getAtomState(void 0, atom);\n\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n\n          if (mounted) {\n            mounted.t.delete(atom);\n\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n\n  const mountDependencies = (atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n\n      const mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.delete(atom);\n\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach(a => {\n      const mounted = mountedMap.get(a);\n\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n\n  const flushPending = version => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(listener => listener(version));\n        }\n      });\n      return;\n    }\n\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(_ref2 => {\n        let [atom, prevAtomState] = _ref2;\n        const atomState = getAtomState(void 0, atom);\n\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n\n        if (prevAtomState && \"i\" in prevAtomState && atomState && !(\"i\" in atomState)) {\n          return;\n        }\n\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(listener => listener());\n      });\n    }\n\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach(l => l());\n    }\n  };\n\n  const commitVersionedAtomStateMap = version => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || \"v\" in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n\n    flushPending(void 0);\n  };\n\n  const subscribeAtom = (atom, callback) => {\n    const mounted = addAtom(atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n\n    flushPending(version);\n  };\n\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: l => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: a => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: a => mountedMap.get(a)\n    };\n  }\n\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\n\nconst createStoreForExport = initialValues => {\n  const store = createStore(initialValues);\n\n  const get = atom => {\n    const atomState = store[READ_ATOM](atom);\n\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n\n    return atomState.v;\n  };\n\n  const asyncGet = atom => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\n\nconst ScopeContextMap = /* @__PURE__ */new Map();\n\nconst getScopeContext = scope => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = _ref3 => {\n  let {\n    children,\n    initialValues,\n    scope,\n    unstable_createStore,\n    unstable_enableVersionedWrite\n  } = _ref3;\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues, unstable_createStore);\n\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = write => {\n        setVersion(parentVersion => {\n          const nextVersion = parentVersion ? {\n            p: parentVersion\n          } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nlet keyCount = 0;\n\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n\n    config.read = get => get(config);\n\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n\n  if (write) {\n    config.write = write;\n  }\n\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const {\n    s: store\n  } = useContext(ScopeContext);\n  const getAtomValue = useCallback(version2 => {\n    const atomState = store[READ_ATOM](atom, version2);\n\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n\n    throw new Error(\"no atom value\");\n  }, [store, atom]);\n  const [[version, value, atomFromUseReducer], rerenderIfChanged] = useReducer(useCallback((prev, nextVersion) => {\n    const nextValue = getAtomValue(nextVersion);\n\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), void 0, () => {\n    const initialVersion = void 0;\n    const initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  });\n\n  if (atomFromUseReducer !== atom) {\n    rerenderIfChanged(void 0);\n  }\n\n  useEffect(() => {\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged);\n    rerenderIfChanged(void 0);\n    return unsubscribe;\n  }, [store, atom]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const {\n    s: store,\n    w: versionedWrite\n  } = useContext(ScopeContext);\n  const setAtom = useCallback(update => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n\n    const write = version => store[WRITE_ATOM](atom, update, version);\n\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n\n  return [useAtomValue(atom, scope), useSetAtom(atom, scope)];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };","map":{"version":3,"names":["createContext","useState","useEffect","useRef","createElement","useContext","useCallback","useReducer","useDebugValue","SUSPENSE_PROMISE","Symbol","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_a","_b","call","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","o","newOriginalPromise","createSuspensePromise","objectToAttach","Promise","resolve","then","__defProp","Object","defineProperty","__defProps","defineProperties","__getOwnPropDescs","getOwnPropertyDescriptors","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","__spreadProps","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","committedAtomStateMap","WeakMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","import","meta","env","MODE","Set","atomState","v","r","d","freeze","console","warn","set","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","get","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","p","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","revision","setAtomValue","nextAtomState","is","Array","from","keys","every","flushPending","setAtomReadError","error","e","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","setAtomInvalidated","i","force","_","aState","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","info","setter","promiseOrVoid2","cancelledVersion","promiseOrVoid","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","mountDependencies","committedAtomState","listener","pending","clear","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","createStoreForExport","store","asyncGet","reject","sub","SECRET_INTERNAL_store","createScopeContainer","unstable_createStore","s","ScopeContextMap","getScopeContext","scope","Provider","children","unstable_enableVersionedWrite","setVersion","scopeContainerRef","current","w","parentVersion","nextVersion","ScopeContainerContext","keyCount","config","toString","useAtomValue","ScopeContext","getAtomValue","version2","atomFromUseReducer","rerenderIfChanged","prev","nextValue","initialVersion","initialValue","unsubscribe","useSetAtom","versionedWrite","useAtom","SECRET_INTERNAL_getScopeContext"],"sources":["/home/odin/Desktop/THPâ˜ /Developpeur/Final_Project/pokeland/node_modules/jotai/esm/index.js"],"sourcesContent":["import { createContext, useState, useEffect, useRef, createElement, useContext, useCallback, useReducer, useDebugValue } from 'react';\n\nconst SUSPENSE_PROMISE = Symbol();\nconst isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];\nconst isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;\nconst cancelSuspensePromise = (suspensePromise) => {\n  var _a, _b;\n  (_b = (_a = suspensePromise[SUSPENSE_PROMISE]).c) == null ? void 0 : _b.call(_a);\n};\nconst isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {\n  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nconst createSuspensePromise = (promise) => {\n  const objectToAttach = {\n    o: promise,\n    c: null\n  };\n  const suspensePromise = new Promise((resolve) => {\n    objectToAttach.c = () => {\n      objectToAttach.c = null;\n      resolve();\n    };\n    promise.then(objectToAttach.c, objectToAttach.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = objectToAttach;\n  return suspensePromise;\n};\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst READ_ATOM = \"r\";\nconst WRITE_ATOM = \"w\";\nconst COMMIT_ATOM = \"c\";\nconst SUBSCRIBE_ATOM = \"s\";\nconst RESTORE_ATOMS = \"h\";\nconst DEV_SUBSCRIBE_STATE = \"n\";\nconst DEV_GET_MOUNTED_ATOMS = \"l\";\nconst DEV_GET_ATOM_STATE = \"a\";\nconst DEV_GET_MOUNTED = \"m\";\nconst createStore = (initialValues) => {\n  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();\n  const mountedMap = /* @__PURE__ */ new WeakMap();\n  const pendingMap = /* @__PURE__ */ new Map();\n  let stateListeners;\n  let mountedAtoms;\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    stateListeners = /* @__PURE__ */ new Set();\n    mountedAtoms = /* @__PURE__ */ new Set();\n  }\n  if (initialValues) {\n    for (const [atom, value] of initialValues) {\n      const atomState = { v: value, r: 0, d: /* @__PURE__ */ new Map() };\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn(\"Found initial value for derived atom which can cause unexpected behavior\", atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();\n  const addSuspensePromiseToCache = (version, atom, suspensePromise) => {\n    let cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = /* @__PURE__ */ new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(() => {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  const cancelAllSuspensePromiseInCache = (atom) => {\n    const versionSet = /* @__PURE__ */ new Set();\n    const cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach((suspensePromise, version) => {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();\n  const getVersionedAtomStateMap = (version) => {\n    let versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = /* @__PURE__ */ new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  const getAtomState = (version, atom) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      let atomState = versionedAtomStateMap.get(atom);\n      if (!atomState) {\n        atomState = getAtomState(version.p, atom);\n        if (atomState) {\n          if (\"p\" in atomState) {\n            atomState.p.then(() => versionedAtomStateMap.delete(atom));\n          }\n          versionedAtomStateMap.set(atom, atomState);\n        }\n      }\n      return atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  const setAtomState = (version, atom, atomState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  const createReadDependencies = (version, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    const readDependencies = /* @__PURE__ */ new Map();\n    let changed = false;\n    dependencies.forEach((atom) => {\n      var _a;\n      const revision = ((_a = getAtomState(version, atom)) == null ? void 0 : _a.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  const setAtomValue = (version, atom, value, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    let changed = false;\n    if (!atomState || !(\"v\" in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a) => atomState.d.has(a)))) {\n      changed = true;\n      Promise.resolve().then(() => {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomReadError = (version, atom, error, dependencies, suspensePromise) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!(\"p\" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if (\"p\" in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    const nextAtomState = {\n      e: error,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomSuspensePromise = (version, atom, suspensePromise, dependencies) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState && \"p\" in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise)) {\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    const nextAtomState = {\n      p: suspensePromise,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  const setAtomPromiseOrValue = (version, atom, promiseOrValue, dependencies) => {\n    if (promiseOrValue instanceof Promise) {\n      const suspensePromise = createSuspensePromise(promiseOrValue.then((value) => {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch((e) => {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(() => {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  const setAtomInvalidated = (version, atom) => {\n    const atomState = getAtomState(version, atom);\n    if (atomState) {\n      const nextAtomState = __spreadProps(__spreadValues({}, atomState), {\n        i: atomState.r\n      });\n      setAtomState(version, atom, nextAtomState);\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not invalidate non existing atom\", atom);\n    }\n  };\n  const readAtomState = (version, atom, force) => {\n    if (!force) {\n      const atomState = getAtomState(version, atom);\n      if (atomState) {\n        if (atomState.r !== atomState.i && \"p\" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n          return atomState;\n        }\n        atomState.d.forEach((_, a) => {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              const aState = getAtomState(version, a);\n              if (aState && aState.r === aState.i) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(atomState.d).every(([a, r]) => {\n          const aState = getAtomState(version, a);\n          return aState && \"v\" in aState && aState.r === r;\n        })) {\n          return atomState;\n        }\n      }\n    }\n    const dependencies = /* @__PURE__ */ new Set();\n    try {\n      const promiseOrValue = atom.read((a) => {\n        dependencies.add(a);\n        const aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if (\"e\" in aState) {\n            throw aState.e;\n          }\n          if (\"p\" in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error(\"no atom init\");\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        const suspensePromise = createSuspensePromise(errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  const readAtom = (readingAtom, version) => {\n    const atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  const addAtom = (addingAtom) => {\n    let mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(addingAtom);\n    }\n    return mounted;\n  };\n  const canUnmountAtom = (atom, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  const delAtom = (deletingAtom) => {\n    const mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(deletingAtom);\n    }\n  };\n  const invalidateDependents = (version, atom) => {\n    const mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach((dependent) => {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  const writeAtomState = (version, atom, update) => {\n    let isSync = true;\n    const writeGetter = (a, options) => {\n      const aState = readAtomState(version, a);\n      if (\"e\" in aState) {\n        throw aState.e;\n      }\n      if (\"p\" in aState) {\n        if (options == null ? void 0 : options.unstable_promise) {\n          return aState.p.then(() => writeGetter(a, options));\n        }\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n          console.info(\"Reading pending atom state in write operation. We throw a promise for now.\", a);\n        }\n        throw aState.p;\n      }\n      if (\"v\" in aState) {\n        return aState.v;\n      }\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n        console.warn(\"[Bug] no value found while reading atom in write operation. This is probably a bug.\", a);\n      }\n      throw new Error(\"no value found\");\n    };\n    const setter = (a, v) => {\n      let promiseOrVoid2;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error(\"atom not writable\");\n        }\n        const versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach((cancelledVersion) => {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        const prevAtomState = getAtomState(version, a);\n        const nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid2 = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid2;\n    };\n    const promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    version = void 0;\n    return promiseOrVoid;\n  };\n  const writeAtom = (writingAtom, update, version) => {\n    const promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  const isActuallyWritableAtom = (atom) => !!atom.write;\n  const mountAtom = (atom, initialDependent) => {\n    const mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: /* @__PURE__ */ new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    const atomState = readAtomState(void 0, atom);\n    atomState.d.forEach((_, a) => {\n      const aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      const setAtom = (update) => writeAtom(atom, update);\n      const onUnmount = atom.onMount(setAtom);\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  const unmountAtom = (atom) => {\n    var _a;\n    const onUnmount = (_a = mountedMap.get(atom)) == null ? void 0 : _a.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    const atomState = getAtomState(void 0, atom);\n    if (atomState) {\n      atomState.d.forEach((_, a) => {\n        if (a !== atom) {\n          const mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      console.warn(\"[Bug] could not find atom state to unmount\", atom);\n    }\n  };\n  const mountDependencies = (atom, atomState, prevReadDependencies) => {\n    const dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_, a) => {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    dependencies.forEach((a) => {\n      const mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  const flushPending = (version) => {\n    if (version) {\n      const versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach((atomState, atom) => {\n        const committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          const mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version));\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      const pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(([atom, prevAtomState]) => {\n        const atomState = getAtomState(void 0, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && \"i\" in prevAtomState && atomState && !(\"i\" in atomState)) {\n          return;\n        }\n        const mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());\n      });\n    }\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n      stateListeners.forEach((l) => l());\n    }\n  };\n  const commitVersionedAtomStateMap = (version) => {\n    const versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach((atomState, atom) => {\n      const prevAtomState = committedAtomStateMap.get(atom);\n      if (atomState.r > ((prevAtomState == null ? void 0 : prevAtomState.r) || 0) || \"v\" in atomState && atomState.r === (prevAtomState == null ? void 0 : prevAtomState.r) && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  const commitAtom = (_atom, version) => {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(void 0);\n  };\n  const subscribeAtom = (atom, callback) => {\n    const mounted = addAtom(atom);\n    const listeners = mounted.l;\n    listeners.add(callback);\n    return () => {\n      listeners.delete(callback);\n      delAtom(atom);\n    };\n  };\n  const restoreAtoms = (values, version) => {\n    for (const [atom, value] of values) {\n      if (hasInitialValue(atom)) {\n        setAtomPromiseOrValue(version, atom, value);\n        invalidateDependents(version, atom);\n      }\n    }\n    flushPending(version);\n  };\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\") {\n    return {\n      [READ_ATOM]: readAtom,\n      [WRITE_ATOM]: writeAtom,\n      [COMMIT_ATOM]: commitAtom,\n      [SUBSCRIBE_ATOM]: subscribeAtom,\n      [RESTORE_ATOMS]: restoreAtoms,\n      [DEV_SUBSCRIBE_STATE]: (l) => {\n        stateListeners.add(l);\n        return () => {\n          stateListeners.delete(l);\n        };\n      },\n      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),\n      [DEV_GET_ATOM_STATE]: (a) => committedAtomStateMap.get(a),\n      [DEV_GET_MOUNTED]: (a) => mountedMap.get(a)\n    };\n  }\n  return {\n    [READ_ATOM]: readAtom,\n    [WRITE_ATOM]: writeAtom,\n    [COMMIT_ATOM]: commitAtom,\n    [SUBSCRIBE_ATOM]: subscribeAtom,\n    [RESTORE_ATOMS]: restoreAtoms\n  };\n};\nconst createStoreForExport = (initialValues) => {\n  const store = createStore(initialValues);\n  const get = (atom) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      return void 0;\n    }\n    return atomState.v;\n  };\n  const asyncGet = (atom) => new Promise((resolve, reject) => {\n    const atomState = store[READ_ATOM](atom);\n    if (\"e\" in atomState) {\n      reject(atomState.e);\n    } else if (\"p\" in atomState) {\n      resolve(atomState.p.then(() => asyncGet(atom)));\n    } else {\n      resolve(atomState.v);\n    }\n  });\n  const set = (atom, update) => store[WRITE_ATOM](atom, update);\n  const sub = (atom, callback) => store[SUBSCRIBE_ATOM](atom, callback);\n  return {\n    get,\n    asyncGet,\n    set,\n    sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nconst createScopeContainer = (initialValues, unstable_createStore) => {\n  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return { s: store };\n};\nconst ScopeContextMap = /* @__PURE__ */ new Map();\nconst getScopeContext = (scope) => {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nconst Provider = ({\n  children,\n  initialValues,\n  scope,\n  unstable_createStore,\n  unstable_enableVersionedWrite\n}) => {\n  const [version, setVersion] = useState({});\n  useEffect(() => {\n    if (version) {\n      scopeContainerRef.current.s[COMMIT_ATOM](null, version);\n      delete version.p;\n    }\n  }, [version]);\n  const scopeContainerRef = useRef();\n  if (!scopeContainerRef.current) {\n    scopeContainerRef.current = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      scopeContainerRef.current.w = (write) => {\n        setVersion((parentVersion) => {\n          const nextVersion = parentVersion ? { p: parentVersion } : {};\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n    }\n  }\n  const ScopeContainerContext = getScopeContext(scope);\n  return createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString: () => key\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = (get) => get(config);\n    config.write = (get, set, update) => set(config, typeof update === \"function\" ? update(get(config)) : update);\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction useAtomValue(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store } = useContext(ScopeContext);\n  const getAtomValue = useCallback((version2) => {\n    const atomState = store[READ_ATOM](atom, version2);\n    if (\"e\" in atomState) {\n      throw atomState.e;\n    }\n    if (\"p\" in atomState) {\n      throw atomState.p;\n    }\n    if (\"v\" in atomState) {\n      return atomState.v;\n    }\n    throw new Error(\"no atom value\");\n  }, [store, atom]);\n  const [[version, value, atomFromUseReducer], rerenderIfChanged] = useReducer(useCallback((prev, nextVersion) => {\n    const nextValue = getAtomValue(nextVersion);\n    if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n      return prev;\n    }\n    return [nextVersion, nextValue, atom];\n  }, [getAtomValue, atom]), void 0, () => {\n    const initialVersion = void 0;\n    const initialValue = getAtomValue(initialVersion);\n    return [initialVersion, initialValue, atom];\n  });\n  if (atomFromUseReducer !== atom) {\n    rerenderIfChanged(void 0);\n  }\n  useEffect(() => {\n    const unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged);\n    rerenderIfChanged(void 0);\n    return unsubscribe;\n  }, [store, atom]);\n  useEffect(() => {\n    store[COMMIT_ATOM](atom, version);\n  });\n  useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  const ScopeContext = getScopeContext(scope);\n  const { s: store, w: versionedWrite } = useContext(ScopeContext);\n  const setAtom = useCallback((update) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !(\"write\" in atom)) {\n      throw new Error(\"not writable atom\");\n    }\n    const write = (version) => store[WRITE_ATOM](atom, update, version);\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if (\"scope\" in atom) {\n    console.warn(\"atom.scope is deprecated. Please do useAtom(atom, scope) instead.\");\n    scope = atom.scope;\n  }\n  return [\n    useAtomValue(atom, scope),\n    useSetAtom(atom, scope)\n  ];\n}\n\nexport { Provider, getScopeContext as SECRET_INTERNAL_getScopeContext, atom, createStoreForExport as unstable_createStore, useAtom, useAtomValue, useSetAtom };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
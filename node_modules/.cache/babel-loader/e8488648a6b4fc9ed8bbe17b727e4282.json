{"ast":null,"code":"import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node) {\n    let shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type) {\n    let shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node) {\n    let output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };","map":{"version":3,"names":["NodeUniform","NodeAttribute","NodeVary","NodeVar","NodeCode","NodeKeywords","NodeUpdateType","REVISION","LinearEncoding","shaderStages","vector","toFloat","value","Number","NodeBuilder","constructor","object","renderer","parser","material","nodes","updateNodes","hashNodes","vertexShader","fragmentShader","flowNodes","vertex","fragment","flowCode","uniforms","index","codes","attributes","varys","vars","flow","code","stack","context","keywords","nodesData","WeakMap","flowsData","shaderStage","node","addStack","push","removeStack","lastStack","pop","Error","setHashNode","hash","addNode","indexOf","updateType","getUpdateType","None","getHash","getMethod","method","getNodeFromHash","addFlow","setContext","getContext","getTexture","console","warn","getTextureBias","getCubeTexture","getCubeTextureBias","getConst","type","Math","round","getType","r","g","b","typeLength","getTypeLength","componentType","getComponentType","x","y","z","w","generateMethod","getAttribute","name","attribute","getPropertyName","isVector","test","isMatrix","isReference","isShaderStage","getTextureEncodingFromMap","map","encoding","isTexture","isWebGLRenderTarget","texture","getVectorType","exec","getTypeFromLength","vecType","vecNum","getVectorFromMatrix","replace","getDataFromNode","nodeData","get","undefined","set","getUniformFromNode","nodeUniform","uniform","getVarFromNode","nodeVar","variable","length","getVaryFromNode","nodeVary","vary","getCodeFromNode","nodeCode","addFlowCode","getFlowData","flowNode","output","getNodeType","flowData","flowChildNode","previousFlow","result","build","flowNodeFromShaderStage","propertyName","previousShaderStage","setShaderStage","getAttributes","getVarys","getVars","snippet","getUniforms","getCodes","getShaderStage","buildCode","analyze","isNode","format","fromType","toType","fromTypeLength","toTypeLength","vectorType","slice","getSignature"],"sources":["/Users/paolucciloic/Desktop/pokemon-projet-final/Pokeland_Final_Project/node_modules/three-stdlib/nodes/core/NodeBuilder.js"],"sourcesContent":["import NodeUniform from './NodeUniform.js';\nimport NodeAttribute from './NodeAttribute.js';\nimport NodeVary from './NodeVary.js';\nimport NodeVar from './NodeVar.js';\nimport NodeCode from './NodeCode.js';\nimport NodeKeywords from './NodeKeywords.js';\nimport { NodeUpdateType } from './constants.js';\nimport { REVISION, LinearEncoding } from 'three';\n\nconst shaderStages = ['fragment', 'vertex'];\nconst vector = ['x', 'y', 'z', 'w'];\n\nconst toFloat = value => {\n  value = Number(value);\n  return value + (value % 1 ? '' : '.0');\n};\n\nclass NodeBuilder {\n  constructor(object, renderer, parser) {\n    this.object = object;\n    this.material = object.material;\n    this.renderer = renderer;\n    this.parser = parser;\n    this.nodes = [];\n    this.updateNodes = [];\n    this.hashNodes = {};\n    this.vertexShader = null;\n    this.fragmentShader = null;\n    this.flowNodes = {\n      vertex: [],\n      fragment: []\n    };\n    this.flowCode = {\n      vertex: '',\n      fragment: ''\n    };\n    this.uniforms = {\n      vertex: [],\n      fragment: [],\n      index: 0\n    };\n    this.codes = {\n      vertex: [],\n      fragment: []\n    };\n    this.attributes = [];\n    this.varys = [];\n    this.vars = {\n      vertex: [],\n      fragment: []\n    };\n    this.flow = {\n      code: ''\n    };\n    this.stack = [];\n    this.context = {\n      keywords: new NodeKeywords(),\n      material: object.material\n    };\n    this.nodesData = new WeakMap();\n    this.flowsData = new WeakMap();\n    this.shaderStage = null;\n    this.node = null;\n  }\n\n  addStack(node) {\n    /*\n    if ( this.stack.indexOf( node ) !== - 1 ) {\n    console.warn( 'Recursive node: ', node );\n    }\n    */\n    this.stack.push(node);\n  }\n\n  removeStack(node) {\n    const lastStack = this.stack.pop();\n\n    if (lastStack !== node) {\n      throw new Error('NodeBuilder: Invalid node stack!');\n    }\n  }\n\n  setHashNode(node, hash) {\n    this.hashNodes[hash] = node;\n  }\n\n  addNode(node) {\n    if (this.nodes.indexOf(node) === -1) {\n      const updateType = node.getUpdateType(this);\n\n      if (updateType !== NodeUpdateType.None) {\n        this.updateNodes.push(node);\n      }\n\n      this.nodes.push(node);\n      this.setHashNode(node, node.getHash(this));\n    }\n  }\n\n  getMethod(method) {\n    return method;\n  }\n\n  getNodeFromHash(hash) {\n    return this.hashNodes[hash];\n  }\n\n  addFlow(shaderStage, node) {\n    this.flowNodes[shaderStage].push(node);\n    return node;\n  }\n\n  setContext(context) {\n    this.context = context;\n  }\n\n  getContext() {\n    return this.context;\n  }\n\n  getTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getTextureBias() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTexture() {\n    console.warn('Abstract function.');\n  }\n\n  getCubeTextureBias() {\n    console.warn('Abstract function.');\n  } // @TODO: rename to .generateConst()\n\n\n  getConst(type, value) {\n    if (type === 'float') return toFloat(value);\n    if (type === 'int') return `${Math.round(value)}`;\n    if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';\n    if (type === 'bool') return value ? 'true' : 'false';\n    if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;\n    const typeLength = this.getTypeLength(type);\n    const componentType = this.getComponentType(type);\n\n    const getConst = value => this.getConst(componentType, value);\n\n    if (typeLength === 2) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;\n    } else if (typeLength === 3) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;\n    } else if (typeLength === 4) {\n      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;\n    }\n\n    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);\n  }\n\n  getType(type) {\n    return type;\n  }\n\n  generateMethod(method) {\n    return method;\n  }\n\n  getAttribute(name, type) {\n    const attributes = this.attributes; // find attribute\n\n    for (const attribute of attributes) {\n      if (attribute.name === name) {\n        return attribute;\n      }\n    } // create a new if no exist\n\n\n    const attribute = new NodeAttribute(name, type);\n    attributes.push(attribute);\n    return attribute;\n  }\n\n  getPropertyName(node\n  /*, shaderStage*/\n  ) {\n    return node.name;\n  }\n\n  isVector(type) {\n    return /vec\\d/.test(type);\n  }\n\n  isMatrix(type) {\n    return /mat\\d/.test(type);\n  }\n\n  isReference(type) {\n    return type === 'void' || type === 'property' || type === 'sampler';\n  }\n\n  isShaderStage(shaderStage) {\n    return this.shaderStage === shaderStage;\n  }\n\n  getTextureEncodingFromMap(map) {\n    let encoding;\n\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n\n    return encoding;\n  }\n\n  getComponentType(type) {\n    type = this.getVectorType(type);\n    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);\n    if (componentType === null) return null;\n    if (componentType[1] === 'b') return 'bool';\n    if (componentType[1] === 'i') return 'int';\n    if (componentType[1] === 'u') return 'uint';\n    return 'float';\n  }\n\n  getVectorType(type) {\n    if (type === 'color') return 'vec3';\n    if (type === 'texture') return 'vec4';\n    return type;\n  }\n\n  getTypeFromLength(type) {\n    if (type === 1) return 'float';\n    if (type === 2) return 'vec2';\n    if (type === 3) return 'vec3';\n    if (type === 4) return 'vec4';\n    return 0;\n  }\n\n  getTypeLength(type) {\n    const vecType = this.getVectorType(type);\n    const vecNum = /vec([2-4])/.exec(vecType);\n    if (vecNum !== null) return Number(vecNum[1]);\n    if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;\n    return 0;\n  }\n\n  getVectorFromMatrix(type) {\n    return type.replace('mat', 'vec');\n  }\n\n  getDataFromNode(node, shaderStage = this.shaderStage) {\n    let nodeData = this.nodesData.get(node);\n\n    if (nodeData === undefined) {\n      nodeData = {\n        vertex: {},\n        fragment: {}\n      };\n      this.nodesData.set(node, nodeData);\n    }\n\n    return shaderStage !== null ? nodeData[shaderStage] : nodeData;\n  }\n\n  getUniformFromNode(node, shaderStage, type) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeUniform = nodeData.uniform;\n\n    if (nodeUniform === undefined) {\n      const index = this.uniforms.index++;\n      nodeUniform = new NodeUniform('nodeUniform' + index, type, node);\n      this.uniforms[shaderStage].push(nodeUniform);\n      nodeData.uniform = nodeUniform;\n    }\n\n    return nodeUniform;\n  }\n\n  getVarFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node, shaderStage);\n    let nodeVar = nodeData.variable;\n\n    if (nodeVar === undefined) {\n      const vars = this.vars[shaderStage];\n      const index = vars.length;\n      nodeVar = new NodeVar('nodeVar' + index, type);\n      vars.push(nodeVar);\n      nodeData.variable = nodeVar;\n    }\n\n    return nodeVar;\n  }\n\n  getVaryFromNode(node, type) {\n    const nodeData = this.getDataFromNode(node, null);\n    let nodeVary = nodeData.vary;\n\n    if (nodeVary === undefined) {\n      const varys = this.varys;\n      const index = varys.length;\n      nodeVary = new NodeVary('nodeVary' + index, type);\n      varys.push(nodeVary);\n      nodeData.vary = nodeVary;\n    }\n\n    return nodeVary;\n  }\n\n  getCodeFromNode(node, type, shaderStage = this.shaderStage) {\n    const nodeData = this.getDataFromNode(node);\n    let nodeCode = nodeData.code;\n\n    if (nodeCode === undefined) {\n      const codes = this.codes[shaderStage];\n      const index = codes.length;\n      nodeCode = new NodeCode('nodeCode' + index, type);\n      codes.push(nodeCode);\n      nodeData.code = nodeCode;\n    }\n\n    return nodeCode;\n  }\n\n  addFlowCode(code) {\n    this.flow.code += code;\n  }\n\n  getFlowData(shaderStage, node) {\n    return this.flowsData.get(node);\n  }\n\n  flowNode(node) {\n    this.node = node;\n    const output = node.getNodeType(this);\n    const flowData = this.flowChildNode(node, output);\n    this.flowsData.set(node, flowData);\n    this.node = null;\n    return flowData;\n  }\n\n  flowChildNode(node, output = null) {\n    const previousFlow = this.flow;\n    const flow = {\n      code: ''\n    };\n    this.flow = flow;\n    flow.result = node.build(this, output);\n    this.flow = previousFlow;\n    return flow;\n  }\n\n  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {\n    const previousShaderStage = this.shaderStage;\n    this.setShaderStage(shaderStage);\n    const flowData = this.flowChildNode(node, output);\n\n    if (propertyName !== null) {\n      flowData.code += `${propertyName} = ${flowData.result};\\n\\t`;\n    }\n\n    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;\n    this.setShaderStage(previousShaderStage);\n    return flowData;\n  }\n\n  getAttributes() {\n    console.warn('Abstract function.');\n  }\n\n  getVarys() {\n    console.warn('Abstract function.');\n  }\n\n  getVars(shaderStage) {\n    let snippet = '';\n    const vars = this.vars[shaderStage];\n\n    for (let index = 0; index < vars.length; index++) {\n      const variable = vars[index];\n      snippet += `${variable.type} ${variable.name}; `;\n    }\n\n    return snippet;\n  }\n\n  getUniforms() {\n    console.warn('Abstract function.');\n  }\n\n  getCodes(shaderStage) {\n    const codes = this.codes[shaderStage];\n    let code = '';\n\n    for (const nodeCode of codes) {\n      code += nodeCode.code + '\\n';\n    }\n\n    return code;\n  }\n\n  getHash() {\n    return this.vertexShader + this.fragmentShader;\n  }\n\n  getShaderStage() {\n    return this.shaderStage;\n  }\n\n  setShaderStage(shaderStage) {\n    this.shaderStage = shaderStage;\n  }\n\n  buildCode() {\n    console.warn('Abstract function.');\n  }\n\n  build() {\n    // stage 1: analyze nodes to possible optimization and validation\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        node.analyze(this);\n      }\n    } // stage 2: pre-build vertex code used in fragment shader\n\n\n    if (this.context.vertex && this.context.vertex.isNode) {\n      this.flowNodeFromShaderStage('vertex', this.context.vertex);\n    } // stage 3: generate shader\n\n\n    for (const shaderStage of shaderStages) {\n      this.setShaderStage(shaderStage);\n      const flowNodes = this.flowNodes[shaderStage];\n\n      for (const node of flowNodes) {\n        this.flowNode(node, shaderStage);\n      }\n    }\n\n    this.setShaderStage(null); // stage 4: build code for a specific output\n\n    this.buildCode();\n    return this;\n  }\n\n  format(snippet, fromType, toType) {\n    fromType = this.getVectorType(fromType);\n    toType = this.getVectorType(toType);\n\n    if (fromType === toType || toType === null || this.isReference(toType)) {\n      return snippet;\n    }\n\n    const fromTypeLength = this.getTypeLength(fromType);\n    const toTypeLength = this.getTypeLength(toType);\n\n    if (fromTypeLength === 0) {\n      // fromType is matrix-like\n      const vectorType = this.getVectorFromMatrix(fromType);\n      return this.format(`( ${snippet} * ${this.getType(vectorType)}( 1.0 ) )`, vectorType, toType);\n    }\n\n    if (toTypeLength === 0) {\n      // toType is matrix-like\n      // ignore for now\n      //return `${ this.getType( toType ) }( ${ snippet } )`;\n      return snippet;\n    }\n\n    if (fromTypeLength === toTypeLength) {\n      return `${this.getType(toType)}( ${snippet} )`;\n    }\n\n    if (fromTypeLength > toTypeLength) {\n      return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);\n    }\n\n    if (toTypeLength === 4) {\n      // toType is vec4-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;\n    }\n\n    if (fromTypeLength === 2) {\n      // fromType is vec2-like and toType is vec3-like\n      return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;\n    }\n\n    return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like\n  }\n\n  getSignature() {\n    return `// Three.js r${REVISION} - NodeMaterial System\\n`;\n  }\n\n}\n\nexport default NodeBuilder;\nexport { shaderStages, vector };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
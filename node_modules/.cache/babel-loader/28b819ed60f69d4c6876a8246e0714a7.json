{"ast":null,"code":"import * as THREE from 'three';\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    } // front and rear face center vertices\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    } // construct front and rear face\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster(); // create cursor\n\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n\n      this._updatePointerVertices(rearRadius);\n\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.pointerGeometry) {\n      this._updatePointer();\n\n      this._updateRaycaster();\n    }\n  }\n\n  isPinched() {\n    return this.pinched;\n  }\n\n  setAttached(attached) {\n    this.attached = attached;\n  }\n\n  isAttached() {\n    return this.attached;\n  }\n\n  intersectObject(object) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n\n  intersectObjects(objects) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n\n  checkIntersections(objects) {\n    let recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n\n}\n\nexport { OculusHandPointerModel };","map":{"version":3,"names":["THREE","PINCH_MAX","PINCH_THRESHOLD","PINCH_MIN","POINTER_ADVANCE_MAX","POINTER_OPACITY_MAX","POINTER_OPACITY_MIN","POINTER_FRONT_RADIUS","POINTER_REAR_RADIUS","POINTER_REAR_RADIUS_MIN","POINTER_LENGTH","POINTER_SEGMENTS","POINTER_RINGS","POINTER_HEMISPHERE_ANGLE","YAXIS","Vector3","ZAXIS","CURSOR_RADIUS","CURSOR_MAX_DISTANCE","OculusHandPointerModel","Object3D","constructor","hand","controller","motionController","envMap","mesh","pointerGeometry","pointerMesh","pointerObject","pinched","attached","cursorObject","raycaster","addEventListener","event","xrInputSource","data","visible","createPointer","_drawVerticesRing","vertices","baseVector","ringIndex","segmentVector","clone","i","applyAxisAngle","Math","PI","vid","x","y","z","_updatePointerVertices","rearRadius","attributes","position","array","frontFaceBase","rearBase","sin","cos","frontCenterIndex","rearCenterIndex","frontCenter","rearCenter","setAttribute","Float32BufferAttribute","j","Array","fill","indices","BufferGeometry","push","material","MeshBasicMaterial","transparent","opacity","setIndex","Mesh","set","add","Raycaster","cursorGeometry","SphereGeometry","cursorMaterial","_updateRaycaster","pointerMatrix","matrixWorld","tempMatrix","Matrix4","identity","extractRotation","ray","origin","setFromMatrixPosition","direction","applyMatrix4","_updatePointer","indexTip","joints","thumbTip","distance","distanceTo","multiplyScalar","copy","quaternion","pinchScale","focusScale","updateMatrixWorld","force","isPinched","setAttached","isAttached","intersectObject","object","recursive","intersectObjects","objects","checkIntersections","intersections","length","intersection","setCursor"],"sources":["/Users/paolucciloic/Desktop/pokemon-projet-final/Pokeland_Final_Project/node_modules/three-stdlib/webxr/OculusHandPointerModel.js"],"sourcesContent":["import * as THREE from 'three';\n\nconst PINCH_MAX = 0.05;\nconst PINCH_THRESHOLD = 0.02;\nconst PINCH_MIN = 0.01;\nconst POINTER_ADVANCE_MAX = 0.02;\nconst POINTER_OPACITY_MAX = 1;\nconst POINTER_OPACITY_MIN = 0.4;\nconst POINTER_FRONT_RADIUS = 0.002;\nconst POINTER_REAR_RADIUS = 0.01;\nconst POINTER_REAR_RADIUS_MIN = 0.003;\nconst POINTER_LENGTH = 0.035;\nconst POINTER_SEGMENTS = 16;\nconst POINTER_RINGS = 12;\nconst POINTER_HEMISPHERE_ANGLE = 110;\nconst YAXIS = new THREE.Vector3(0, 1, 0);\nconst ZAXIS = new THREE.Vector3(0, 0, 1);\nconst CURSOR_RADIUS = 0.02;\nconst CURSOR_MAX_DISTANCE = 1.5;\n\nclass OculusHandPointerModel extends THREE.Object3D {\n  constructor(hand, controller) {\n    super();\n    this.hand = hand;\n    this.controller = controller;\n    this.motionController = null;\n    this.envMap = null;\n    this.mesh = null;\n    this.pointerGeometry = null;\n    this.pointerMesh = null;\n    this.pointerObject = null;\n    this.pinched = false;\n    this.attached = false;\n    this.cursorObject = null;\n    this.raycaster = null;\n    hand.addEventListener('connected', event => {\n      const xrInputSource = event.data;\n\n      if (xrInputSource.hand) {\n        this.visible = true;\n        this.xrInputSource = xrInputSource;\n        this.createPointer();\n      }\n    });\n  }\n\n  _drawVerticesRing(vertices, baseVector, ringIndex) {\n    const segmentVector = baseVector.clone();\n\n    for (var i = 0; i < POINTER_SEGMENTS; i++) {\n      segmentVector.applyAxisAngle(ZAXIS, Math.PI * 2 / POINTER_SEGMENTS);\n      const vid = ringIndex * POINTER_SEGMENTS + i;\n      vertices[3 * vid] = segmentVector.x;\n      vertices[3 * vid + 1] = segmentVector.y;\n      vertices[3 * vid + 2] = segmentVector.z;\n    }\n  }\n\n  _updatePointerVertices(rearRadius) {\n    const vertices = this.pointerGeometry.attributes.position.array; // first ring for front face\n\n    const frontFaceBase = new THREE.Vector3(POINTER_FRONT_RADIUS, 0, -1 * (POINTER_LENGTH - rearRadius));\n\n    this._drawVerticesRing(vertices, frontFaceBase, 0); // rings for rear hemisphere\n\n\n    const rearBase = new THREE.Vector3(Math.sin(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, Math.cos(Math.PI * POINTER_HEMISPHERE_ANGLE / 180) * rearRadius, 0);\n\n    for (var i = 0; i < POINTER_RINGS; i++) {\n      this._drawVerticesRing(vertices, rearBase, i + 1);\n\n      rearBase.applyAxisAngle(YAXIS, Math.PI * POINTER_HEMISPHERE_ANGLE / 180 / (POINTER_RINGS * -2));\n    } // front and rear face center vertices\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n    const frontCenter = new THREE.Vector3(0, 0, -1 * (POINTER_LENGTH - rearRadius));\n    vertices[frontCenterIndex * 3] = frontCenter.x;\n    vertices[frontCenterIndex * 3 + 1] = frontCenter.y;\n    vertices[frontCenterIndex * 3 + 2] = frontCenter.z;\n    const rearCenter = new THREE.Vector3(0, 0, rearRadius);\n    vertices[rearCenterIndex * 3] = rearCenter.x;\n    vertices[rearCenterIndex * 3 + 1] = rearCenter.y;\n    vertices[rearCenterIndex * 3 + 2] = rearCenter.z;\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3)); // verticesNeedUpdate = true;\n  }\n\n  createPointer() {\n    var i, j;\n    const vertices = new Array(((POINTER_RINGS + 1) * POINTER_SEGMENTS + 2) * 3).fill(0); // const vertices = [];\n\n    const indices = [];\n    this.pointerGeometry = new THREE.BufferGeometry();\n    this.pointerGeometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));\n\n    this._updatePointerVertices(POINTER_REAR_RADIUS); // construct faces to connect rings\n\n\n    for (i = 0; i < POINTER_RINGS; i++) {\n      for (j = 0; j < POINTER_SEGMENTS - 1; j++) {\n        indices.push(i * POINTER_SEGMENTS + j, i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n        indices.push(i * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j + 1, (i + 1) * POINTER_SEGMENTS + j);\n      }\n\n      indices.push((i + 1) * POINTER_SEGMENTS - 1, i * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n      indices.push(i * POINTER_SEGMENTS, (i + 1) * POINTER_SEGMENTS, (i + 2) * POINTER_SEGMENTS - 1);\n    } // construct front and rear face\n\n\n    const frontCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS);\n    const rearCenterIndex = POINTER_SEGMENTS * (1 + POINTER_RINGS) + 1;\n\n    for (i = 0; i < POINTER_SEGMENTS - 1; i++) {\n      indices.push(frontCenterIndex, i + 1, i);\n      indices.push(rearCenterIndex, i + POINTER_SEGMENTS * POINTER_RINGS, i + POINTER_SEGMENTS * POINTER_RINGS + 1);\n    }\n\n    indices.push(frontCenterIndex, 0, POINTER_SEGMENTS - 1);\n    indices.push(rearCenterIndex, POINTER_SEGMENTS * (POINTER_RINGS + 1) - 1, POINTER_SEGMENTS * POINTER_RINGS);\n    const material = new THREE.MeshBasicMaterial();\n    material.transparent = true;\n    material.opacity = POINTER_OPACITY_MIN;\n    this.pointerGeometry.setIndex(indices);\n    this.pointerMesh = new THREE.Mesh(this.pointerGeometry, material);\n    this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n    this.pointerObject = new THREE.Object3D();\n    this.pointerObject.add(this.pointerMesh);\n    this.raycaster = new THREE.Raycaster(); // create cursor\n\n    const cursorGeometry = new THREE.SphereGeometry(CURSOR_RADIUS, 10, 10);\n    const cursorMaterial = new THREE.MeshBasicMaterial();\n    cursorMaterial.transparent = true;\n    cursorMaterial.opacity = POINTER_OPACITY_MIN;\n    this.cursorObject = new THREE.Mesh(cursorGeometry, cursorMaterial);\n    this.pointerObject.add(this.cursorObject);\n    this.add(this.pointerObject);\n  }\n\n  _updateRaycaster() {\n    if (this.raycaster) {\n      const pointerMatrix = this.pointerObject.matrixWorld;\n      const tempMatrix = new THREE.Matrix4();\n      tempMatrix.identity().extractRotation(pointerMatrix);\n      this.raycaster.ray.origin.setFromMatrixPosition(pointerMatrix);\n      this.raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);\n    }\n  }\n\n  _updatePointer() {\n    this.pointerObject.visible = this.controller.visible;\n    const indexTip = this.hand.joints['index-finger-tip'];\n    const thumbTip = this.hand.joints['thumb-tip'];\n    const distance = indexTip.position.distanceTo(thumbTip.position);\n    const position = indexTip.position.clone().add(thumbTip.position).multiplyScalar(0.5);\n    this.pointerObject.position.copy(position);\n    this.pointerObject.quaternion.copy(this.controller.quaternion);\n    this.pinched = distance <= PINCH_THRESHOLD;\n    const pinchScale = (distance - PINCH_MIN) / (PINCH_MAX - PINCH_MIN);\n    const focusScale = (distance - PINCH_MIN) / (PINCH_THRESHOLD - PINCH_MIN);\n\n    if (pinchScale > 1) {\n      this._updatePointerVertices(POINTER_REAR_RADIUS);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n    } else if (pinchScale > 0) {\n      const rearRadius = (POINTER_REAR_RADIUS - POINTER_REAR_RADIUS_MIN) * pinchScale + POINTER_REAR_RADIUS_MIN;\n\n      this._updatePointerVertices(rearRadius);\n\n      if (focusScale < 1) {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius - (1 - focusScale) * POINTER_ADVANCE_MAX);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN + (1 - focusScale) * (POINTER_OPACITY_MAX - POINTER_OPACITY_MIN);\n      } else {\n        this.pointerMesh.position.set(0, 0, -1 * rearRadius);\n        this.pointerMesh.material.opacity = POINTER_OPACITY_MIN;\n      }\n    } else {\n      this._updatePointerVertices(POINTER_REAR_RADIUS_MIN);\n\n      this.pointerMesh.position.set(0, 0, -1 * POINTER_REAR_RADIUS_MIN - POINTER_ADVANCE_MAX);\n      this.pointerMesh.material.opacity = POINTER_OPACITY_MAX;\n    }\n\n    this.cursorObject.material.opacity = this.pointerMesh.material.opacity;\n  }\n\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n\n    if (this.pointerGeometry) {\n      this._updatePointer();\n\n      this._updateRaycaster();\n    }\n  }\n\n  isPinched() {\n    return this.pinched;\n  }\n\n  setAttached(attached) {\n    this.attached = attached;\n  }\n\n  isAttached() {\n    return this.attached;\n  }\n\n  intersectObject(object, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObject(object, recursive);\n    }\n  }\n\n  intersectObjects(objects, recursive = true) {\n    if (this.raycaster) {\n      return this.raycaster.intersectObjects(objects, recursive);\n    }\n  }\n\n  checkIntersections(objects, recursive = false) {\n    if (this.raycaster && !this.attached) {\n      const intersections = this.raycaster.intersectObjects(objects, recursive);\n      const direction = new THREE.Vector3(0, 0, -1);\n\n      if (intersections.length > 0) {\n        const intersection = intersections[0];\n        const distance = intersection.distance;\n        this.cursorObject.position.copy(direction.multiplyScalar(distance));\n      } else {\n        this.cursorObject.position.copy(direction.multiplyScalar(CURSOR_MAX_DISTANCE));\n      }\n    }\n  }\n\n  setCursor(distance) {\n    const direction = new THREE.Vector3(0, 0, -1);\n\n    if (this.raycaster && !this.attached) {\n      this.cursorObject.position.copy(direction.multiplyScalar(distance));\n    }\n  }\n\n}\n\nexport { OculusHandPointerModel };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\nimport { buildPackedTree } from './buildFunctions.js';\nimport { raycast, raycastFirst, shapecast, intersectsGeometry, setBuffer, clearBuffer } from './castFunctions.js';\nimport { OrientedBox } from '../math/OrientedBox.js';\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\nconst SKIP_GENERATION = Symbol('skip tree generation');\nconst aabb = /* @__PURE__ */new Box3();\nconst aabb2 = /* @__PURE__ */new Box3();\nconst tempMatrix = /* @__PURE__ */new Matrix4();\nconst obb = /* @__PURE__ */new OrientedBox();\nconst obb2 = /* @__PURE__ */new OrientedBox();\nconst temp = /* @__PURE__ */new Vector3();\nconst temp1 = /* @__PURE__ */new Vector3();\nconst temp2 = /* @__PURE__ */new Vector3();\nconst temp3 = /* @__PURE__ */new Vector3();\nconst temp4 = /* @__PURE__ */new Vector3();\nconst tempBox = /* @__PURE__ */new Box3();\nconst trianglePool = /* @__PURE__ */new PrimitivePool(() => new ExtendedTriangle());\nexport class MeshBVH {\n  static serialize(bvh) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (options.isBufferGeometry) {\n      console.warn('MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.');\n      return MeshBVH.serialize(arguments[0], {\n        cloneBuffers: arguments[2] === undefined ? true : arguments[2]\n      });\n    }\n\n    options = {\n      cloneBuffers: true,\n      ...options\n    };\n    const geometry = bvh.geometry;\n    const rootData = bvh._roots;\n    const indexAttribute = geometry.getIndex();\n    let result;\n\n    if (options.cloneBuffers) {\n      result = {\n        roots: rootData.map(root => root.slice()),\n        index: indexAttribute.array.slice()\n      };\n    } else {\n      result = {\n        roots: rootData,\n        index: indexAttribute.array\n      };\n    }\n\n    return result;\n  }\n\n  static deserialize(data, geometry) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof options === 'boolean') {\n      console.warn('MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.');\n      return MeshBVH.deserialize(arguments[0], arguments[1], {\n        setIndex: arguments[2] === undefined ? true : arguments[2]\n      });\n    }\n\n    options = {\n      setIndex: true,\n      ...options\n    };\n    const {\n      index,\n      roots\n    } = data;\n    const bvh = new MeshBVH(geometry, { ...options,\n      [SKIP_GENERATION]: true\n    });\n    bvh._roots = roots;\n\n    if (options.setIndex) {\n      const indexAttribute = geometry.getIndex();\n\n      if (indexAttribute === null) {\n        const newIndex = new BufferAttribute(data.index, 1, false);\n        geometry.setIndex(newIndex);\n      } else if (indexAttribute.array !== index) {\n        indexAttribute.array.set(index);\n        indexAttribute.needsUpdate = true;\n      }\n    }\n\n    return bvh;\n  }\n\n  constructor(geometry) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!geometry.isBufferGeometry) {\n      throw new Error('MeshBVH: Only BufferGeometries are supported.');\n    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n      throw new Error('MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.');\n    } // default options\n\n\n    options = Object.assign({\n      strategy: CENTER,\n      maxDepth: 40,\n      maxLeafTris: 10,\n      verbose: true,\n      useSharedArrayBuffer: false,\n      setBoundingBox: true,\n      onProgress: null,\n      // undocumented options\n      // Whether to skip generating the tree. Used for deserialization.\n      [SKIP_GENERATION]: false\n    }, options);\n\n    if (options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined') {\n      throw new Error('MeshBVH: SharedArrayBuffer is not available.');\n    }\n\n    this._roots = null;\n\n    if (!options[SKIP_GENERATION]) {\n      this._roots = buildPackedTree(geometry, options);\n\n      if (!geometry.boundingBox && options.setBoundingBox) {\n        geometry.boundingBox = this.getBoundingBox(new Box3());\n      }\n    } // retain references to the geometry so we can use them it without having to\n    // take a geometry reference in every function.\n\n\n    this.geometry = geometry;\n  }\n\n  refit() {\n    let nodeIndices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n      nodeIndices = new Set(nodeIndices);\n    }\n\n    const geometry = this.geometry;\n    const indexArr = geometry.index.array;\n    const posAttr = geometry.attributes.position;\n    const posArr = posAttr.array; // support for an interleaved position buffer\n\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n\n    if (posAttr.isInterleavedBufferAttribute) {\n      stride = posAttr.data.stride;\n    }\n\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = this._roots;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      buffer = roots[i];\n      uint32Array = new Uint32Array(buffer);\n      uint16Array = new Uint16Array(buffer);\n      float32Array = new Float32Array(buffer);\n\n      _traverse(0, byteOffset);\n\n      byteOffset += buffer.byteLength;\n    }\n\n    function _traverse(node32Index, byteOffset) {\n      let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        let minx = Infinity;\n        let miny = Infinity;\n        let minz = Infinity;\n        let maxx = -Infinity;\n        let maxy = -Infinity;\n        let maxz = -Infinity;\n\n        for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {\n          const index = indexArr[i] * stride + bufferOffset;\n          const x = posArr[index + 0];\n          const y = posArr[index + 1];\n          const z = posArr[index + 2];\n          if (x < minx) minx = x;\n          if (x > maxx) maxx = x;\n          if (y < miny) miny = y;\n          if (y > maxy) maxy = y;\n          if (z < minz) minz = z;\n          if (z > maxz) maxz = z;\n        }\n\n        if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n          float32Array[node32Index + 0] = minx;\n          float32Array[node32Index + 1] = miny;\n          float32Array[node32Index + 2] = minz;\n          float32Array[node32Index + 3] = maxx;\n          float32Array[node32Index + 4] = maxy;\n          float32Array[node32Index + 5] = maxz;\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        const left = node32Index + 8;\n        const right = uint32Array[node32Index + 6]; // the identifying node indices provided by the shapecast function include offsets of all\n        // root buffers to guarantee they're unique between roots so offset left and right indices here.\n\n        const offsetLeft = left + byteOffset;\n        const offsetRight = right + byteOffset;\n        let forceChildren = force;\n        let includesLeft = false;\n        let includesRight = false;\n\n        if (nodeIndices) {\n          // if we see that neither the left or right child are included in the set that need to be updated\n          // then we assume that all children need to be updated.\n          if (!forceChildren) {\n            includesLeft = nodeIndices.has(offsetLeft);\n            includesRight = nodeIndices.has(offsetRight);\n            forceChildren = !includesLeft && !includesRight;\n          }\n        } else {\n          includesLeft = true;\n          includesRight = true;\n        }\n\n        const traverseLeft = forceChildren || includesLeft;\n        const traverseRight = forceChildren || includesRight;\n        let leftChange = false;\n\n        if (traverseLeft) {\n          leftChange = _traverse(left, byteOffset, forceChildren);\n        }\n\n        let rightChange = false;\n\n        if (traverseRight) {\n          rightChange = _traverse(right, byteOffset, forceChildren);\n        }\n\n        const didChange = leftChange || rightChange;\n\n        if (didChange) {\n          for (let i = 0; i < 3; i++) {\n            const lefti = left + i;\n            const righti = right + i;\n            const minLeftValue = float32Array[lefti];\n            const maxLeftValue = float32Array[lefti + 3];\n            const minRightValue = float32Array[righti];\n            const maxRightValue = float32Array[righti + 3];\n            float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n            float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n          }\n        }\n\n        return didChange;\n      }\n    }\n  }\n\n  traverse(callback) {\n    let rootIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const buffer = this._roots[rootIndex];\n    const uint32Array = new Uint32Array(buffer);\n    const uint16Array = new Uint16Array(buffer);\n\n    _traverse(0);\n\n    function _traverse(node32Index) {\n      let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      const node16Index = node32Index * 2;\n      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;\n\n      if (isLeaf) {\n        const offset = uint32Array[node32Index + 6];\n        const count = uint16Array[node16Index + 14];\n        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n      } else {\n        // TODO: use node functions here\n        const left = node32Index + BYTES_PER_NODE / 4;\n        const right = uint32Array[node32Index + 6];\n        const splitAxis = uint32Array[node32Index + 7];\n        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n\n        if (!stopTraversal) {\n          _traverse(left, depth + 1);\n\n          _traverse(right, depth + 1);\n        }\n      }\n    }\n  }\n  /* Core Cast Functions */\n\n\n  raycast(ray) {\n    let materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const intersects = [];\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      const startCount = intersects.length;\n      setBuffer(roots[i]);\n      raycast(0, geometry, materialSide, ray, intersects);\n      clearBuffer();\n\n      if (isArrayMaterial) {\n        const materialIndex = groups[i].materialIndex;\n\n        for (let j = startCount, jl = intersects.length; j < jl; j++) {\n          intersects[j].face.materialIndex = materialIndex;\n        }\n      }\n    }\n\n    return intersects;\n  }\n\n  raycastFirst(ray) {\n    let materialOrSide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : FrontSide;\n    const roots = this._roots;\n    const geometry = this.geometry;\n    const isMaterial = materialOrSide.isMaterial;\n    const isArrayMaterial = Array.isArray(materialOrSide);\n    let closestResult = null;\n    const groups = geometry.groups;\n    const side = isMaterial ? materialOrSide.side : materialOrSide;\n\n    for (let i = 0, l = roots.length; i < l; i++) {\n      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n      setBuffer(roots[i]);\n      const result = raycastFirst(0, geometry, materialSide, ray);\n      clearBuffer();\n\n      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n        closestResult = result;\n\n        if (isArrayMaterial) {\n          result.face.materialIndex = groups[i].materialIndex;\n        }\n      }\n    }\n\n    return closestResult;\n  }\n\n  intersectsGeometry(otherGeometry, geomToMesh) {\n    const geometry = this.geometry;\n    let result = false;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = intersectsGeometry(0, geometry, otherGeometry, geomToMesh);\n      clearBuffer();\n\n      if (result) {\n        break;\n      }\n    }\n\n    return result;\n  }\n\n  shapecast(callbacks, _intersectsTriangleFunc, _orderNodesFunc) {\n    const geometry = this.geometry;\n\n    if (callbacks instanceof Function) {\n      if (_intersectsTriangleFunc) {\n        // Support the previous function signature that provided three sequential index buffer\n        // indices here.\n        const originalTriangleFunc = _intersectsTriangleFunc;\n\n        _intersectsTriangleFunc = (tri, index, contained, depth) => {\n          const i3 = index * 3;\n          return originalTriangleFunc(tri, i3, i3 + 1, i3 + 2, contained, depth);\n        };\n      }\n\n      callbacks = {\n        boundsTraverseOrder: _orderNodesFunc,\n        intersectsBounds: callbacks,\n        intersectsTriangle: _intersectsTriangleFunc,\n        intersectsRange: null\n      };\n      console.warn('MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.');\n    }\n\n    const triangle = trianglePool.getPrimitive();\n    let {\n      boundsTraverseOrder,\n      intersectsBounds,\n      intersectsRange,\n      intersectsTriangle\n    } = callbacks;\n\n    if (intersectsRange && intersectsTriangle) {\n      const originalIntersectsRange = intersectsRange;\n\n      intersectsRange = (offset, count, contained, depth, nodeIndex) => {\n        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        }\n\n        return true;\n      };\n    } else if (!intersectsRange) {\n      if (intersectsTriangle) {\n        intersectsRange = (offset, count, contained, depth) => {\n          return iterateOverTriangles(offset, count, geometry, intersectsTriangle, contained, depth, triangle);\n        };\n      } else {\n        intersectsRange = (offset, count, contained) => {\n          return contained;\n        };\n      }\n    }\n\n    let result = false;\n    let byteOffset = 0;\n\n    for (const root of this._roots) {\n      setBuffer(root);\n      result = shapecast(0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n      clearBuffer();\n\n      if (result) {\n        break;\n      }\n\n      byteOffset += root.byteLength;\n    }\n\n    trianglePool.releasePrimitive(triangle);\n    return result;\n  }\n\n  bvhcast(otherBvh, matrixToLocal, callbacks) {\n    // BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\n    // than an approach that walks down the tree (see bvhcast.js file for more info).\n    let {\n      intersectsRanges,\n      intersectsTriangles\n    } = callbacks;\n    const indexAttr = this.geometry.index;\n    const positionAttr = this.geometry.attributes.position;\n    const otherIndexAttr = otherBvh.geometry.index;\n    const otherPositionAttr = otherBvh.geometry.attributes.position;\n    tempMatrix.copy(matrixToLocal).invert();\n    const triangle = trianglePool.getPrimitive();\n    const triangle2 = trianglePool.getPrimitive();\n\n    if (intersectsTriangles) {\n      function iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {\n          setTriangle(triangle2, i2 * 3, otherIndexAttr, otherPositionAttr);\n          triangle2.a.applyMatrix4(matrixToLocal);\n          triangle2.b.applyMatrix4(matrixToLocal);\n          triangle2.c.applyMatrix4(matrixToLocal);\n          triangle2.needsUpdate = true;\n\n          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {\n            setTriangle(triangle, i1 * 3, indexAttr, positionAttr);\n            triangle.needsUpdate = true;\n\n            if (intersectsTriangles(triangle, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n              return true;\n            }\n          }\n        }\n\n        return false;\n      }\n\n      if (intersectsRanges) {\n        const originalIntersectsRanges = intersectsRanges;\n\n        intersectsRanges = function (offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n          }\n\n          return true;\n        };\n      } else {\n        intersectsRanges = iterateOverDoubleTriangles;\n      }\n    }\n\n    otherBvh.getBoundingBox(aabb2);\n    aabb2.applyMatrix4(matrixToLocal);\n    const result = this.shapecast({\n      intersectsBounds: box => aabb2.intersectsBox(box),\n      intersectsRange: (offset1, count1, contained, depth1, nodeIndex1, box) => {\n        aabb.copy(box);\n        aabb.applyMatrix4(tempMatrix);\n        return otherBvh.shapecast({\n          intersectsBounds: box => aabb.intersectsBox(box),\n          intersectsRange: (offset2, count2, contained, depth2, nodeIndex2) => {\n            return intersectsRanges(offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2);\n          }\n        });\n      }\n    });\n    trianglePool.releasePrimitive(triangle);\n    trianglePool.releasePrimitive(triangle2);\n    return result;\n  }\n  /* Derived Cast Functions */\n\n\n  intersectsBox(box, boxToMesh) {\n    obb.set(box.min, box.max, boxToMesh);\n    obb.needsUpdate = true;\n    return this.shapecast({\n      intersectsBounds: box => obb.intersectsBox(box),\n      intersectsTriangle: tri => obb.intersectsTriangle(tri)\n    });\n  }\n\n  intersectsSphere(sphere) {\n    return this.shapecast({\n      intersectsBounds: box => sphere.intersectsBox(box),\n      intersectsTriangle: tri => tri.intersectsSphere(sphere)\n    });\n  }\n\n  closestPointToGeometry(otherGeometry, geometryToBvh) {\n    let target1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let target2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let minThreshold = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n    let maxThreshold = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Infinity;\n\n    if (!otherGeometry.boundingBox) {\n      otherGeometry.computeBoundingBox();\n    }\n\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = this.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = trianglePool.getPrimitive();\n    const triangle2 = trianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n\n    if (target2) {\n      tempTarget2 = temp3;\n      tempTargetDest2 = temp4;\n    }\n\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    this.shapecast({\n      boundsTraverseOrder: box => {\n        return obb.distanceToBox(box);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        if (score < closestDistance && score < maxThreshold) {\n          // if we know the triangles of this bounds will be intersected next then\n          // save the bounds to use during triangle checks.\n          if (isLeaf) {\n            obb2.min.copy(box.min);\n            obb2.max.copy(box.max);\n            obb2.needsUpdate = true;\n          }\n\n          return true;\n        }\n\n        return false;\n      },\n      intersectsRange: (offset, count) => {\n        if (otherGeometry.boundsTree) {\n          // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n          // the closest bounds in the other geometry to check.\n          return otherGeometry.boundsTree.shapecast({\n            boundsTraverseOrder: box => {\n              return obb2.distanceToBox(box);\n            },\n            intersectsBounds: (box, isLeaf, score) => {\n              return score < closestDistance && score < maxThreshold;\n            },\n            intersectsRange: (otherOffset, otherCount) => {\n              for (let i2 = otherOffset * 3, l2 = (otherOffset + otherCount) * 3; i2 < l2; i2 += 3) {\n                setTriangle(triangle2, i2, otherIndex, otherPos);\n                triangle2.a.applyMatrix4(geometryToBvh);\n                triangle2.b.applyMatrix4(geometryToBvh);\n                triangle2.c.applyMatrix4(geometryToBvh);\n                triangle2.needsUpdate = true;\n\n                for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n                  setTriangle(triangle, i, index, pos);\n                  triangle.needsUpdate = true;\n                  const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n                  if (dist < closestDistance) {\n                    tempTargetDest1.copy(tempTarget1);\n\n                    if (tempTargetDest2) {\n                      tempTargetDest2.copy(tempTarget2);\n                    }\n\n                    closestDistance = dist;\n                    closestDistanceTriIndex = i / 3;\n                    closestDistanceOtherTriIndex = i2 / 3;\n                  } // stop traversal if we find a point that's under the given threshold\n\n\n                  if (dist < minThreshold) {\n                    return true;\n                  }\n                }\n              }\n            }\n          });\n        } else {\n          // If no bounds tree then we'll just check every triangle.\n          const triCount = otherIndex ? otherIndex.count : otherPos.count;\n\n          for (let i2 = 0, l2 = triCount; i2 < l2; i2 += 3) {\n            setTriangle(triangle2, i2, otherIndex, otherPos);\n            triangle2.a.applyMatrix4(geometryToBvh);\n            triangle2.b.applyMatrix4(geometryToBvh);\n            triangle2.c.applyMatrix4(geometryToBvh);\n            triangle2.needsUpdate = true;\n\n            for (let i = offset * 3, l = (offset + count) * 3; i < l; i += 3) {\n              setTriangle(triangle, i, index, pos);\n              triangle.needsUpdate = true;\n              const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n\n              if (dist < closestDistance) {\n                tempTargetDest1.copy(tempTarget1);\n\n                if (tempTargetDest2) {\n                  tempTargetDest2.copy(tempTarget2);\n                }\n\n                closestDistance = dist;\n                closestDistanceTriIndex = i / 3;\n                closestDistanceOtherTriIndex = i2 / 3;\n              } // stop traversal if we find a point that's under the given threshold\n\n\n              if (dist < minThreshold) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    });\n    trianglePool.releasePrimitive(triangle);\n    trianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity) return null;\n    if (!target1.point) target1.point = tempTargetDest1.clone();else target1.point.copy(tempTargetDest1);\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n\n    if (target2) {\n      if (!target2.point) target2.point = tempTargetDest2.clone();else target2.point.copy(tempTargetDest2);\n      target2.point.applyMatrix4(tempMatrix);\n      tempTargetDest1.applyMatrix4(tempMatrix);\n      target2.distance = tempTargetDest1.sub(target2.point).length();\n      target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n\n    return target1;\n  }\n\n  closestPointToPoint(point) {\n    let target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let minThreshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let maxThreshold = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    this.shapecast({\n      boundsTraverseOrder: box => {\n        temp.copy(point).clamp(box.min, box.max);\n        return temp.distanceToSquared(point);\n      },\n      intersectsBounds: (box, isLeaf, score) => {\n        return score < closestDistanceSq && score < maxThresholdSq;\n      },\n      intersectsTriangle: (tri, triIndex) => {\n        tri.closestPointToPoint(point, temp);\n        const distSq = point.distanceToSquared(temp);\n\n        if (distSq < closestDistanceSq) {\n          temp1.copy(temp);\n          closestDistanceSq = distSq;\n          closestDistanceTriIndex = triIndex;\n        }\n\n        if (distSq < minThresholdSq) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = temp1.clone();else target.point.copy(temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n  }\n\n  getBoundingBox(target) {\n    target.makeEmpty();\n    const roots = this._roots;\n    roots.forEach(buffer => {\n      arrayToBox(0, new Float32Array(buffer), tempBox);\n      target.union(tempBox);\n    });\n    return target;\n  }\n\n} // Deprecation\n\nconst originalRaycast = MeshBVH.prototype.raycast;\n\nMeshBVH.prototype.raycast = function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.');\n    const [mesh, raycaster, ray, intersects] = args;\n    const results = originalRaycast.call(this, ray, mesh.material);\n    results.forEach(hit => {\n      hit = convertRaycastIntersect(hit, mesh, raycaster);\n\n      if (hit) {\n        intersects.push(hit);\n      }\n    });\n    return intersects;\n  } else {\n    return originalRaycast.apply(this, args);\n  }\n};\n\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\n\nMeshBVH.prototype.raycastFirst = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.');\n    const [mesh, raycaster, ray] = args;\n    return convertRaycastIntersect(originalRaycastFirst.call(this, ray, mesh.material), mesh, raycaster);\n  } else {\n    return originalRaycastFirst.apply(this, args);\n  }\n};\n\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\n\nMeshBVH.prototype.closestPointToPoint = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  if (args[0].isMesh) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.');\n    args.unshift();\n    const target = args[1];\n    const result = {};\n    args[1] = result;\n    originalClosestPointToPoint.apply(this, args);\n\n    if (target) {\n      target.copy(result.point);\n    }\n\n    return result.distance;\n  } else {\n    return originalClosestPointToPoint.apply(this, args);\n  }\n};\n\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\n\nMeshBVH.prototype.closestPointToGeometry = function () {\n  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  const target1 = args[2];\n  const target2 = args[3];\n\n  if (target1 && target1.isVector3 || target2 && target2.isVector3) {\n    console.warn('MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.');\n    const result1 = {};\n    const result2 = {};\n    const geometryToBvh = args[1];\n    args[2] = result1;\n    args[3] = result2;\n    originalClosestPointToGeometry.apply(this, args);\n\n    if (target1) {\n      target1.copy(result1.point);\n    }\n\n    if (target2) {\n      target2.copy(result2.point).applyMatrix4(geometryToBvh);\n    }\n\n    return result1.distance;\n  } else {\n    return originalClosestPointToGeometry.apply(this, args);\n  }\n};\n\nconst originalRefit = MeshBVH.prototype.refit;\n\nMeshBVH.prototype.refit = function () {\n  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n    args[_key5] = arguments[_key5];\n  }\n\n  const nodeIndices = args[0];\n  const terminationIndices = args[1];\n\n  if (terminationIndices && (terminationIndices instanceof Set || Array.isArray(terminationIndices))) {\n    console.warn('MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.');\n    const newNodeIndices = new Set();\n    terminationIndices.forEach(v => newNodeIndices.add(v));\n\n    if (nodeIndices) {\n      nodeIndices.forEach(v => newNodeIndices.add(v));\n    }\n\n    originalRefit.call(this, newNodeIndices);\n  } else {\n    originalRefit.apply(this, args);\n  }\n};\n\n['intersectsGeometry', 'shapecast', 'intersectsBox', 'intersectsSphere'].forEach(name => {\n  const originalFunc = MeshBVH.prototype[name];\n\n  MeshBVH.prototype[name] = function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    if (args[0] === null || args[0].isMesh) {\n      args.shift();\n      console.warn(`MeshBVH: The function signature for \"${name}\" has changed and no longer takes Mesh. See docs for new signature.`);\n    }\n\n    return originalFunc.apply(this, args);\n  };\n});","map":{"version":3,"names":["Vector3","BufferAttribute","Box3","FrontSide","Matrix4","CENTER","BYTES_PER_NODE","IS_LEAFNODE_FLAG","buildPackedTree","raycast","raycastFirst","shapecast","intersectsGeometry","setBuffer","clearBuffer","OrientedBox","ExtendedTriangle","PrimitivePool","arrayToBox","iterateOverTriangles","setTriangle","convertRaycastIntersect","SKIP_GENERATION","Symbol","aabb","aabb2","tempMatrix","obb","obb2","temp","temp1","temp2","temp3","temp4","tempBox","trianglePool","MeshBVH","serialize","bvh","options","isBufferGeometry","console","warn","arguments","cloneBuffers","undefined","geometry","rootData","_roots","indexAttribute","getIndex","result","roots","map","root","slice","index","array","deserialize","data","setIndex","newIndex","set","needsUpdate","constructor","Error","isInterleavedBufferAttribute","Object","assign","strategy","maxDepth","maxLeafTris","verbose","useSharedArrayBuffer","setBoundingBox","onProgress","SharedArrayBuffer","boundingBox","getBoundingBox","refit","nodeIndices","Array","isArray","Set","indexArr","posAttr","attributes","position","posArr","bufferOffset","offset","stride","buffer","uint32Array","uint16Array","float32Array","byteOffset","i","l","length","Uint32Array","Uint16Array","Float32Array","_traverse","byteLength","node32Index","force","node16Index","isLeaf","count","minx","Infinity","miny","minz","maxx","maxy","maxz","x","y","z","left","right","offsetLeft","offsetRight","forceChildren","includesLeft","includesRight","has","traverseLeft","traverseRight","leftChange","rightChange","didChange","lefti","righti","minLeftValue","maxLeftValue","minRightValue","maxRightValue","traverse","callback","rootIndex","depth","splitAxis","stopTraversal","ray","materialOrSide","intersects","isMaterial","isArrayMaterial","groups","side","materialSide","materialIndex","startCount","j","jl","face","closestResult","distance","otherGeometry","geomToMesh","callbacks","_intersectsTriangleFunc","_orderNodesFunc","Function","originalTriangleFunc","tri","contained","i3","boundsTraverseOrder","intersectsBounds","intersectsTriangle","intersectsRange","triangle","getPrimitive","originalIntersectsRange","nodeIndex","releasePrimitive","bvhcast","otherBvh","matrixToLocal","intersectsRanges","intersectsTriangles","indexAttr","positionAttr","otherIndexAttr","otherPositionAttr","copy","invert","triangle2","iterateOverDoubleTriangles","offset1","count1","offset2","count2","depth1","index1","depth2","index2","i2","l2","a","applyMatrix4","b","c","i1","l1","originalIntersectsRanges","box","intersectsBox","nodeIndex1","nodeIndex2","boxToMesh","min","max","intersectsSphere","sphere","closestPointToGeometry","geometryToBvh","target1","target2","minThreshold","maxThreshold","computeBoundingBox","pos","otherPos","otherIndex","tempTarget1","tempTargetDest1","tempTarget2","tempTargetDest2","closestDistance","closestDistanceTriIndex","closestDistanceOtherTriIndex","matrix","distanceToBox","score","boundsTree","otherOffset","otherCount","dist","distanceToTriangle","triCount","point","clone","faceIndex","sub","closestPointToPoint","target","minThresholdSq","maxThresholdSq","closestDistanceSq","clamp","distanceToSquared","triIndex","distSq","Math","sqrt","makeEmpty","forEach","union","originalRaycast","prototype","args","isMesh","mesh","raycaster","results","call","material","hit","push","apply","originalRaycastFirst","originalClosestPointToPoint","unshift","originalClosestPointToGeometry","isVector3","result1","result2","originalRefit","terminationIndices","newNodeIndices","v","add","name","originalFunc","shift"],"sources":["/home/odin/Desktop/THP☠/Developpeur/Final_Project/pokeland/node_modules/three-mesh-bvh/src/core/MeshBVH.js"],"sourcesContent":["import { Vector3, BufferAttribute, Box3, FrontSide, Matrix4 } from 'three';\r\nimport { CENTER, BYTES_PER_NODE, IS_LEAFNODE_FLAG } from './Constants.js';\r\nimport { buildPackedTree } from './buildFunctions.js';\r\nimport {\r\n\traycast,\r\n\traycastFirst,\r\n\tshapecast,\r\n\tintersectsGeometry,\r\n\tsetBuffer,\r\n\tclearBuffer,\r\n} from './castFunctions.js';\r\nimport { OrientedBox } from '../math/OrientedBox.js';\r\nimport { ExtendedTriangle } from '../math/ExtendedTriangle.js';\r\nimport { PrimitivePool } from '../utils/PrimitivePool.js';\r\nimport { arrayToBox } from '../utils/ArrayBoxUtilities.js';\r\nimport { iterateOverTriangles, setTriangle } from '../utils/TriangleUtilities.js';\r\nimport { convertRaycastIntersect } from '../utils/GeometryRayIntersectUtilities.js';\r\n\r\nconst SKIP_GENERATION = Symbol( 'skip tree generation' );\r\n\r\nconst aabb = /* @__PURE__ */ new Box3();\r\nconst aabb2 = /* @__PURE__ */ new Box3();\r\nconst tempMatrix = /* @__PURE__ */ new Matrix4();\r\nconst obb = /* @__PURE__ */ new OrientedBox();\r\nconst obb2 = /* @__PURE__ */ new OrientedBox();\r\nconst temp = /* @__PURE__ */ new Vector3();\r\nconst temp1 = /* @__PURE__ */ new Vector3();\r\nconst temp2 = /* @__PURE__ */ new Vector3();\r\nconst temp3 = /* @__PURE__ */ new Vector3();\r\nconst temp4 = /* @__PURE__ */ new Vector3();\r\nconst tempBox = /* @__PURE__ */ new Box3();\r\nconst trianglePool = /* @__PURE__ */ new PrimitivePool( () => new ExtendedTriangle() );\r\n\r\nexport class MeshBVH {\r\n\r\n\tstatic serialize( bvh, options = {} ) {\r\n\r\n\t\tif ( options.isBufferGeometry ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.serialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tcloneBuffers: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tcloneBuffers: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst geometry = bvh.geometry;\r\n\t\tconst rootData = bvh._roots;\r\n\t\tconst indexAttribute = geometry.getIndex();\r\n\t\tlet result;\r\n\t\tif ( options.cloneBuffers ) {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData.map( root => root.slice() ),\r\n\t\t\t\tindex: indexAttribute.array.slice(),\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = {\r\n\t\t\t\troots: rootData,\r\n\t\t\t\tindex: indexAttribute.array,\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tstatic deserialize( data, geometry, options = {} ) {\r\n\r\n\t\tif ( typeof options === 'boolean' ) {\r\n\r\n\t\t\tconsole.warn( 'MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature.' );\r\n\r\n\t\t\treturn MeshBVH.deserialize(\r\n\t\t\t\targuments[ 0 ],\r\n\t\t\t\targuments[ 1 ],\r\n\t\t\t\t{\r\n\t\t\t\t\tsetIndex: arguments[ 2 ] === undefined ? true : arguments[ 2 ],\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t}\r\n\r\n\t\toptions = {\r\n\t\t\tsetIndex: true,\r\n\t\t\t...options,\r\n\t\t};\r\n\r\n\t\tconst { index, roots } = data;\r\n\t\tconst bvh = new MeshBVH( geometry, { ...options, [ SKIP_GENERATION ]: true } );\r\n\t\tbvh._roots = roots;\r\n\r\n\t\tif ( options.setIndex ) {\r\n\r\n\t\t\tconst indexAttribute = geometry.getIndex();\r\n\t\t\tif ( indexAttribute === null ) {\r\n\r\n\t\t\t\tconst newIndex = new BufferAttribute( data.index, 1, false );\r\n\t\t\t\tgeometry.setIndex( newIndex );\r\n\r\n\t\t\t} else if ( indexAttribute.array !== index ) {\r\n\r\n\t\t\t\tindexAttribute.array.set( index );\r\n\t\t\t\tindexAttribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn bvh;\r\n\r\n\t}\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tif ( ! geometry.isBufferGeometry ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: Only BufferGeometries are supported.' );\r\n\r\n\t\t} else if ( geometry.index && geometry.index.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.' );\r\n\r\n\t\t}\r\n\r\n\t\t// default options\r\n\t\toptions = Object.assign( {\r\n\r\n\t\t\tstrategy: CENTER,\r\n\t\t\tmaxDepth: 40,\r\n\t\t\tmaxLeafTris: 10,\r\n\t\t\tverbose: true,\r\n\t\t\tuseSharedArrayBuffer: false,\r\n\t\t\tsetBoundingBox: true,\r\n\t\t\tonProgress: null,\r\n\r\n\t\t\t// undocumented options\r\n\r\n\t\t\t// Whether to skip generating the tree. Used for deserialization.\r\n\t\t\t[ SKIP_GENERATION ]: false,\r\n\r\n\t\t}, options );\r\n\r\n\t\tif ( options.useSharedArrayBuffer && typeof SharedArrayBuffer === 'undefined' ) {\r\n\r\n\t\t\tthrow new Error( 'MeshBVH: SharedArrayBuffer is not available.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis._roots = null;\r\n\t\tif ( ! options[ SKIP_GENERATION ] ) {\r\n\r\n\t\t\tthis._roots = buildPackedTree( geometry, options );\r\n\r\n\t\t\tif ( ! geometry.boundingBox && options.setBoundingBox ) {\r\n\r\n\t\t\t\tgeometry.boundingBox = this.getBoundingBox( new Box3() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// retain references to the geometry so we can use them it without having to\r\n\t\t// take a geometry reference in every function.\r\n\t\tthis.geometry = geometry;\r\n\r\n\t}\r\n\r\n\trefit( nodeIndices = null ) {\r\n\r\n\t\tif ( nodeIndices && Array.isArray( nodeIndices ) ) {\r\n\r\n\t\t\tnodeIndices = new Set( nodeIndices );\r\n\r\n\t\t}\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst indexArr = geometry.index.array;\r\n\t\tconst posAttr = geometry.attributes.position;\r\n\t\tconst posArr = posAttr.array;\r\n\r\n\t\t// support for an interleaved position buffer\r\n\t\tconst bufferOffset = posAttr.offset || 0;\r\n\t\tlet stride = 3;\r\n\t\tif ( posAttr.isInterleavedBufferAttribute ) {\r\n\r\n\t\t\tstride = posAttr.data.stride;\r\n\r\n\t\t}\r\n\r\n\t\tlet buffer, uint32Array, uint16Array, float32Array;\r\n\t\tlet byteOffset = 0;\r\n\t\tconst roots = this._roots;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tbuffer = roots[ i ];\r\n\t\t\tuint32Array = new Uint32Array( buffer );\r\n\t\t\tuint16Array = new Uint16Array( buffer );\r\n\t\t\tfloat32Array = new Float32Array( buffer );\r\n\r\n\t\t\t_traverse( 0, byteOffset );\r\n\t\t\tbyteOffset += buffer.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\tfunction _traverse( node32Index, byteOffset, force = false ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\r\n\t\t\t\tlet minx = Infinity;\r\n\t\t\t\tlet miny = Infinity;\r\n\t\t\t\tlet minz = Infinity;\r\n\t\t\t\tlet maxx = - Infinity;\r\n\t\t\t\tlet maxy = - Infinity;\r\n\t\t\t\tlet maxz = - Infinity;\r\n\t\t\t\tfor ( let i = 3 * offset, l = 3 * ( offset + count ); i < l; i ++ ) {\r\n\r\n\t\t\t\t\tconst index = indexArr[ i ] * stride + bufferOffset;\r\n\t\t\t\t\tconst x = posArr[ index + 0 ];\r\n\t\t\t\t\tconst y = posArr[ index + 1 ];\r\n\t\t\t\t\tconst z = posArr[ index + 2 ];\r\n\r\n\t\t\t\t\tif ( x < minx ) minx = x;\r\n\t\t\t\t\tif ( x > maxx ) maxx = x;\r\n\r\n\t\t\t\t\tif ( y < miny ) miny = y;\r\n\t\t\t\t\tif ( y > maxy ) maxy = y;\r\n\r\n\t\t\t\t\tif ( z < minz ) minz = z;\r\n\t\t\t\t\tif ( z > maxz ) maxz = z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] !== minx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] !== miny ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] !== minz ||\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] !== maxx ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] !== maxy ||\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] !== maxz\r\n\t\t\t\t) {\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 0 ] = minx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 1 ] = miny;\r\n\t\t\t\t\tfloat32Array[ node32Index + 2 ] = minz;\r\n\r\n\t\t\t\t\tfloat32Array[ node32Index + 3 ] = maxx;\r\n\t\t\t\t\tfloat32Array[ node32Index + 4 ] = maxy;\r\n\t\t\t\t\tfloat32Array[ node32Index + 5 ] = maxz;\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconst left = node32Index + 8;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\r\n\t\t\t\t// the identifying node indices provided by the shapecast function include offsets of all\r\n\t\t\t\t// root buffers to guarantee they're unique between roots so offset left and right indices here.\r\n\t\t\t\tconst offsetLeft = left + byteOffset;\r\n\t\t\t\tconst offsetRight = right + byteOffset;\r\n\t\t\t\tlet forceChildren = force;\r\n\t\t\t\tlet includesLeft = false;\r\n\t\t\t\tlet includesRight = false;\r\n\r\n\t\t\t\tif ( nodeIndices ) {\r\n\r\n\t\t\t\t\t// if we see that neither the left or right child are included in the set that need to be updated\r\n\t\t\t\t\t// then we assume that all children need to be updated.\r\n\t\t\t\t\tif ( ! forceChildren ) {\r\n\r\n\t\t\t\t\t\tincludesLeft = nodeIndices.has( offsetLeft );\r\n\t\t\t\t\t\tincludesRight = nodeIndices.has( offsetRight );\r\n\t\t\t\t\t\tforceChildren = ! includesLeft && ! includesRight;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tincludesLeft = true;\r\n\t\t\t\t\tincludesRight = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst traverseLeft = forceChildren || includesLeft;\r\n\t\t\t\tconst traverseRight = forceChildren || includesRight;\r\n\r\n\t\t\t\tlet leftChange = false;\r\n\t\t\t\tif ( traverseLeft ) {\r\n\r\n\t\t\t\t\tleftChange = _traverse( left, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet rightChange = false;\r\n\t\t\t\tif ( traverseRight ) {\r\n\r\n\t\t\t\t\trightChange = _traverse( right, byteOffset, forceChildren );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst didChange = leftChange || rightChange;\r\n\t\t\t\tif ( didChange ) {\r\n\r\n\t\t\t\t\tfor ( let i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\tconst lefti = left + i;\r\n\t\t\t\t\t\tconst righti = right + i;\r\n\t\t\t\t\t\tconst minLeftValue = float32Array[ lefti ];\r\n\t\t\t\t\t\tconst maxLeftValue = float32Array[ lefti + 3 ];\r\n\t\t\t\t\t\tconst minRightValue = float32Array[ righti ];\r\n\t\t\t\t\t\tconst maxRightValue = float32Array[ righti + 3 ];\r\n\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i ] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\r\n\t\t\t\t\t\tfloat32Array[ node32Index + i + 3 ] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn didChange;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\ttraverse( callback, rootIndex = 0 ) {\r\n\r\n\t\tconst buffer = this._roots[ rootIndex ];\r\n\t\tconst uint32Array = new Uint32Array( buffer );\r\n\t\tconst uint16Array = new Uint16Array( buffer );\r\n\t\t_traverse( 0 );\r\n\r\n\t\tfunction _traverse( node32Index, depth = 0 ) {\r\n\r\n\t\t\tconst node16Index = node32Index * 2;\r\n\t\t\tconst isLeaf = uint16Array[ node16Index + 15 ] === IS_LEAFNODE_FLAG;\r\n\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\tconst offset = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst count = uint16Array[ node16Index + 14 ];\r\n\t\t\t\tcallback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), offset, count );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// TODO: use node functions here\r\n\t\t\t\tconst left = node32Index + BYTES_PER_NODE / 4;\r\n\t\t\t\tconst right = uint32Array[ node32Index + 6 ];\r\n\t\t\t\tconst splitAxis = uint32Array[ node32Index + 7 ];\r\n\t\t\t\tconst stopTraversal = callback( depth, isLeaf, new Float32Array( buffer, node32Index * 4, 6 ), splitAxis );\r\n\r\n\t\t\t\tif ( ! stopTraversal ) {\r\n\r\n\t\t\t\t\t_traverse( left, depth + 1 );\r\n\t\t\t\t\t_traverse( right, depth + 1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Core Cast Functions */\r\n\traycast( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst intersects = [];\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\t\t\tconst startCount = intersects.length;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\traycast( 0, geometry, materialSide, ray, intersects );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\tconst materialIndex = groups[ i ].materialIndex;\r\n\t\t\t\tfor ( let j = startCount, jl = intersects.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tintersects[ j ].face.materialIndex = materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn intersects;\r\n\r\n\t}\r\n\r\n\traycastFirst( ray, materialOrSide = FrontSide ) {\r\n\r\n\t\tconst roots = this._roots;\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst isMaterial = materialOrSide.isMaterial;\r\n\t\tconst isArrayMaterial = Array.isArray( materialOrSide );\r\n\r\n\t\tlet closestResult = null;\r\n\r\n\t\tconst groups = geometry.groups;\r\n\t\tconst side = isMaterial ? materialOrSide.side : materialOrSide;\r\n\t\tfor ( let i = 0, l = roots.length; i < l; i ++ ) {\r\n\r\n\t\t\tconst materialSide = isArrayMaterial ? materialOrSide[ groups[ i ].materialIndex ].side : side;\r\n\r\n\t\t\tsetBuffer( roots[ i ] );\r\n\t\t\tconst result = raycastFirst( 0, geometry, materialSide, ray );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result != null && ( closestResult == null || result.distance < closestResult.distance ) ) {\r\n\r\n\t\t\t\tclosestResult = result;\r\n\t\t\t\tif ( isArrayMaterial ) {\r\n\r\n\t\t\t\t\tresult.face.materialIndex = groups[ i ].materialIndex;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn closestResult;\r\n\r\n\t}\r\n\r\n\tintersectsGeometry( otherGeometry, geomToMesh ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tlet result = false;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = intersectsGeometry( 0, geometry, otherGeometry, geomToMesh );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tshapecast( callbacks, _intersectsTriangleFunc, _orderNodesFunc ) {\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tif ( callbacks instanceof Function ) {\r\n\r\n\t\t\tif ( _intersectsTriangleFunc ) {\r\n\r\n\t\t\t\t// Support the previous function signature that provided three sequential index buffer\r\n\t\t\t\t// indices here.\r\n\t\t\t\tconst originalTriangleFunc = _intersectsTriangleFunc;\r\n\t\t\t\t_intersectsTriangleFunc = ( tri, index, contained, depth ) => {\r\n\r\n\t\t\t\t\tconst i3 = index * 3;\r\n\t\t\t\t\treturn originalTriangleFunc( tri, i3, i3 + 1, i3 + 2, contained, depth );\r\n\r\n\t\t\t\t};\r\n\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcallbacks = {\r\n\r\n\t\t\t\tboundsTraverseOrder: _orderNodesFunc,\r\n\t\t\t\tintersectsBounds: callbacks,\r\n\t\t\t\tintersectsTriangle: _intersectsTriangleFunc,\r\n\t\t\t\tintersectsRange: null,\r\n\r\n\t\t\t};\r\n\r\n\t\t\tconsole.warn( 'MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.' );\r\n\r\n\t\t}\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tlet {\r\n\t\t\tboundsTraverseOrder,\r\n\t\t\tintersectsBounds,\r\n\t\t\tintersectsRange,\r\n\t\t\tintersectsTriangle,\r\n\t\t} = callbacks;\r\n\r\n\t\tif ( intersectsRange && intersectsTriangle ) {\r\n\r\n\t\t\tconst originalIntersectsRange = intersectsRange;\r\n\t\t\tintersectsRange = ( offset, count, contained, depth, nodeIndex ) => {\r\n\r\n\t\t\t\tif ( ! originalIntersectsRange( offset, count, contained, depth, nodeIndex ) ) {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\r\n\t\t\t};\r\n\r\n\t\t} else if ( ! intersectsRange ) {\r\n\r\n\t\t\tif ( intersectsTriangle ) {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained, depth ) => {\r\n\r\n\t\t\t\t\treturn iterateOverTriangles( offset, count, geometry, intersectsTriangle, contained, depth, triangle );\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRange = ( offset, count, contained ) => {\r\n\r\n\t\t\t\t\treturn contained;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlet result = false;\r\n\t\tlet byteOffset = 0;\r\n\t\tfor ( const root of this._roots ) {\r\n\r\n\t\t\tsetBuffer( root );\r\n\t\t\tresult = shapecast( 0, geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset );\r\n\t\t\tclearBuffer();\r\n\r\n\t\t\tif ( result ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbyteOffset += root.byteLength;\r\n\r\n\t\t}\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tbvhcast( otherBvh, matrixToLocal, callbacks ) {\r\n\r\n\t\t// BVHCast function for intersecting two BVHs against each other. Ultimately just uses two recursive shapecast calls rather\r\n\t\t// than an approach that walks down the tree (see bvhcast.js file for more info).\r\n\r\n\t\tlet {\r\n\t\t\tintersectsRanges,\r\n\t\t\tintersectsTriangles,\r\n\t\t} = callbacks;\r\n\r\n\t\tconst indexAttr = this.geometry.index;\r\n\t\tconst positionAttr = this.geometry.attributes.position;\r\n\r\n\t\tconst otherIndexAttr = otherBvh.geometry.index;\r\n\t\tconst otherPositionAttr = otherBvh.geometry.attributes.position;\r\n\r\n\t\ttempMatrix.copy( matrixToLocal ).invert();\r\n\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tif ( intersectsTriangles ) {\r\n\r\n\t\t\tfunction iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\tfor ( let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2 ++ ) {\r\n\r\n\t\t\t\t\tsetTriangle( triangle2, i2 * 3, otherIndexAttr, otherPositionAttr );\r\n\t\t\t\t\ttriangle2.a.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.b.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.c.applyMatrix4( matrixToLocal );\r\n\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\tfor ( let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1 ++ ) {\r\n\r\n\t\t\t\t\t\tsetTriangle( triangle, i1 * 3, indexAttr, positionAttr );\r\n\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\tif ( intersectsTriangles( triangle, triangle2, i1, i2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersectsRanges ) {\r\n\r\n\t\t\t\tconst originalIntersectsRanges = intersectsRanges;\r\n\t\t\t\tintersectsRanges = function ( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) {\r\n\r\n\t\t\t\t\tif ( ! originalIntersectsRanges( offset1, count1, offset2, count2, depth1, index1, depth2, index2 ) ) {\r\n\r\n\t\t\t\t\t\treturn iterateOverDoubleTriangles( offset1, count1, offset2, count2, depth1, index1, depth2, index2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersectsRanges = iterateOverDoubleTriangles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\totherBvh.getBoundingBox( aabb2 );\r\n\t\taabb2.applyMatrix4( matrixToLocal );\r\n\t\tconst result = this.shapecast( {\r\n\r\n\t\t\tintersectsBounds: box => aabb2.intersectsBox( box ),\r\n\r\n\t\t\tintersectsRange: ( offset1, count1, contained, depth1, nodeIndex1, box ) => {\r\n\r\n\t\t\t\taabb.copy( box );\r\n\t\t\t\taabb.applyMatrix4( tempMatrix );\r\n\t\t\t\treturn otherBvh.shapecast( {\r\n\r\n\t\t\t\t\tintersectsBounds: box => aabb.intersectsBox( box ),\r\n\r\n\t\t\t\t\tintersectsRange: ( offset2, count2, contained, depth2, nodeIndex2 ) => {\r\n\r\n\t\t\t\t\t\treturn intersectsRanges( offset1, count1, offset2, count2, depth1, nodeIndex1, depth2, nodeIndex2 );\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t/* Derived Cast Functions */\r\n\tintersectsBox( box, boxToMesh ) {\r\n\r\n\t\tobb.set( box.min, box.max, boxToMesh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => obb.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => obb.intersectsTriangle( tri )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tintersectsSphere( sphere ) {\r\n\r\n\t\treturn this.shapecast(\r\n\t\t\t{\r\n\t\t\t\tintersectsBounds: box => sphere.intersectsBox( box ),\r\n\t\t\t\tintersectsTriangle: tri => tri.intersectsSphere( sphere )\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tclosestPointToGeometry( otherGeometry, geometryToBvh, target1 = { }, target2 = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\tif ( ! otherGeometry.boundingBox ) {\r\n\r\n\t\t\totherGeometry.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tobb.set( otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh );\r\n\t\tobb.needsUpdate = true;\r\n\r\n\t\tconst geometry = this.geometry;\r\n\t\tconst pos = geometry.attributes.position;\r\n\t\tconst index = geometry.index;\r\n\t\tconst otherPos = otherGeometry.attributes.position;\r\n\t\tconst otherIndex = otherGeometry.index;\r\n\t\tconst triangle = trianglePool.getPrimitive();\r\n\t\tconst triangle2 = trianglePool.getPrimitive();\r\n\r\n\t\tlet tempTarget1 = temp1;\r\n\t\tlet tempTargetDest1 = temp2;\r\n\t\tlet tempTarget2 = null;\r\n\t\tlet tempTargetDest2 = null;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttempTarget2 = temp3;\r\n\t\t\ttempTargetDest2 = temp4;\r\n\r\n\t\t}\r\n\r\n\t\tlet closestDistance = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tlet closestDistanceOtherTriIndex = null;\r\n\t\ttempMatrix.copy( geometryToBvh ).invert();\r\n\t\tobb2.matrix.copy( tempMatrix );\r\n\t\tthis.shapecast(\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\treturn obb.distanceToBox( box );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\tif ( score < closestDistance && score < maxThreshold ) {\r\n\r\n\t\t\t\t\t\t// if we know the triangles of this bounds will be intersected next then\r\n\t\t\t\t\t\t// save the bounds to use during triangle checks.\r\n\t\t\t\t\t\tif ( isLeaf ) {\r\n\r\n\t\t\t\t\t\t\tobb2.min.copy( box.min );\r\n\t\t\t\t\t\t\tobb2.max.copy( box.max );\r\n\t\t\t\t\t\t\tobb2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsRange: ( offset, count ) => {\r\n\r\n\t\t\t\t\tif ( otherGeometry.boundsTree ) {\r\n\r\n\t\t\t\t\t\t// if the other geometry has a bvh then use the accelerated path where we use shapecast to find\r\n\t\t\t\t\t\t// the closest bounds in the other geometry to check.\r\n\t\t\t\t\t\treturn otherGeometry.boundsTree.shapecast( {\r\n\t\t\t\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\t\t\t\treturn obb2.distanceToBox( box );\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\t\t\t\treturn score < closestDistance && score < maxThreshold;\r\n\r\n\t\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t\tintersectsRange: ( otherOffset, otherCount ) => {\r\n\r\n\t\t\t\t\t\t\t\tfor ( let i2 = otherOffset * 3, l2 = ( otherOffset + otherCount ) * 3; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// If no bounds tree then we'll just check every triangle.\r\n\t\t\t\t\t\tconst triCount = otherIndex ? otherIndex.count : otherPos.count;\r\n\t\t\t\t\t\tfor ( let i2 = 0, l2 = triCount; i2 < l2; i2 += 3 ) {\r\n\r\n\t\t\t\t\t\t\tsetTriangle( triangle2, i2, otherIndex, otherPos );\r\n\t\t\t\t\t\t\ttriangle2.a.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.b.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.c.applyMatrix4( geometryToBvh );\r\n\t\t\t\t\t\t\ttriangle2.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\tfor ( let i = offset * 3, l = ( offset + count ) * 3; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\t\tsetTriangle( triangle, i, index, pos );\r\n\t\t\t\t\t\t\t\ttriangle.needsUpdate = true;\r\n\r\n\t\t\t\t\t\t\t\tconst dist = triangle.distanceToTriangle( triangle2, tempTarget1, tempTarget2 );\r\n\t\t\t\t\t\t\t\tif ( dist < closestDistance ) {\r\n\r\n\t\t\t\t\t\t\t\t\ttempTargetDest1.copy( tempTarget1 );\r\n\r\n\t\t\t\t\t\t\t\t\tif ( tempTargetDest2 ) {\r\n\r\n\t\t\t\t\t\t\t\t\t\ttempTargetDest2.copy( tempTarget2 );\r\n\r\n\t\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t\tclosestDistance = dist;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceTriIndex = i / 3;\r\n\t\t\t\t\t\t\t\t\tclosestDistanceOtherTriIndex = i2 / 3;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\t// stop traversal if we find a point that's under the given threshold\r\n\t\t\t\t\t\t\t\tif ( dist < minThreshold ) {\r\n\r\n\t\t\t\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\ttrianglePool.releasePrimitive( triangle );\r\n\t\ttrianglePool.releasePrimitive( triangle2 );\r\n\r\n\t\tif ( closestDistance === Infinity ) return null;\r\n\r\n\t\tif ( ! target1.point ) target1.point = tempTargetDest1.clone();\r\n\t\telse target1.point.copy( tempTargetDest1 );\r\n\t\ttarget1.distance = closestDistance,\r\n\t\ttarget1.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\tif ( ! target2.point ) target2.point = tempTargetDest2.clone();\r\n\t\t\telse target2.point.copy( tempTargetDest2 );\r\n\t\t\ttarget2.point.applyMatrix4( tempMatrix );\r\n\t\t\ttempTargetDest1.applyMatrix4( tempMatrix );\r\n\t\t\ttarget2.distance = tempTargetDest1.sub( target2.point ).length();\r\n\t\t\ttarget2.faceIndex = closestDistanceOtherTriIndex;\r\n\r\n\t\t}\r\n\r\n\t\treturn target1;\r\n\r\n\t}\r\n\r\n\tclosestPointToPoint( point, target = { }, minThreshold = 0, maxThreshold = Infinity ) {\r\n\r\n\t\t// early out if under minThreshold\r\n\t\t// skip checking if over maxThreshold\r\n\t\t// set minThreshold = maxThreshold to quickly check if a point is within a threshold\r\n\t\t// returns Infinity if no value found\r\n\t\tconst minThresholdSq = minThreshold * minThreshold;\r\n\t\tconst maxThresholdSq = maxThreshold * maxThreshold;\r\n\t\tlet closestDistanceSq = Infinity;\r\n\t\tlet closestDistanceTriIndex = null;\r\n\t\tthis.shapecast(\r\n\r\n\t\t\t{\r\n\r\n\t\t\t\tboundsTraverseOrder: box => {\r\n\r\n\t\t\t\t\ttemp.copy( point ).clamp( box.min, box.max );\r\n\t\t\t\t\treturn temp.distanceToSquared( point );\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsBounds: ( box, isLeaf, score ) => {\r\n\r\n\t\t\t\t\treturn score < closestDistanceSq && score < maxThresholdSq;\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tintersectsTriangle: ( tri, triIndex ) => {\r\n\r\n\t\t\t\t\ttri.closestPointToPoint( point, temp );\r\n\t\t\t\t\tconst distSq = point.distanceToSquared( temp );\r\n\t\t\t\t\tif ( distSq < closestDistanceSq ) {\r\n\r\n\t\t\t\t\t\ttemp1.copy( temp );\r\n\t\t\t\t\t\tclosestDistanceSq = distSq;\r\n\t\t\t\t\t\tclosestDistanceTriIndex = triIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( distSq < minThresholdSq ) {\r\n\r\n\t\t\t\t\t\treturn true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t}\r\n\r\n\t\t);\r\n\r\n\t\tif ( closestDistanceSq === Infinity ) return null;\r\n\r\n\t\tconst closestDistance = Math.sqrt( closestDistanceSq );\r\n\r\n\t\tif ( ! target.point ) target.point = temp1.clone();\r\n\t\telse target.point.copy( temp1 );\r\n\t\ttarget.distance = closestDistance,\r\n\t\ttarget.faceIndex = closestDistanceTriIndex;\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n\tgetBoundingBox( target ) {\r\n\r\n\t\ttarget.makeEmpty();\r\n\r\n\t\tconst roots = this._roots;\r\n\t\troots.forEach( buffer => {\r\n\r\n\t\t\tarrayToBox( 0, new Float32Array( buffer ), tempBox );\r\n\t\t\ttarget.union( tempBox );\r\n\r\n\t\t} );\r\n\r\n\t\treturn target;\r\n\r\n\t}\r\n\r\n}\r\n\r\n// Deprecation\r\nconst originalRaycast = MeshBVH.prototype.raycast;\r\nMeshBVH.prototype.raycast = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycast\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray, intersects,\r\n\t\t] = args;\r\n\r\n\t\tconst results = originalRaycast.call( this, ray, mesh.material );\r\n\t\tresults.forEach( hit => {\r\n\r\n\t\t\thit = convertRaycastIntersect( hit, mesh, raycaster );\r\n\t\t\tif ( hit ) {\r\n\r\n\t\t\t\tintersects.push( hit );\r\n\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\t\treturn intersects;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycast.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRaycastFirst = MeshBVH.prototype.raycastFirst;\r\nMeshBVH.prototype.raycastFirst = function ( ...args ) {\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"raycastFirst\" has changed. See docs for new signature.' );\r\n\t\tconst [\r\n\t\t\tmesh, raycaster, ray,\r\n\t\t] = args;\r\n\r\n\t\treturn convertRaycastIntersect( originalRaycastFirst.call( this, ray, mesh.material ), mesh, raycaster );\r\n\r\n\t} else {\r\n\r\n\t\treturn originalRaycastFirst.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToPoint = MeshBVH.prototype.closestPointToPoint;\r\nMeshBVH.prototype.closestPointToPoint = function ( ...args ) {\r\n\r\n\r\n\tif ( args[ 0 ].isMesh ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToPoint\" has changed. See docs for new signature.' );\r\n\r\n\t\targs.unshift();\r\n\r\n\t\tconst target = args[ 1 ];\r\n\t\tconst result = {};\r\n\t\targs[ 1 ] = result;\r\n\r\n\t\toriginalClosestPointToPoint.apply( this, args );\r\n\r\n\t\tif ( target ) {\r\n\r\n\t\t\ttarget.copy( result.point );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToPoint.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalClosestPointToGeometry = MeshBVH.prototype.closestPointToGeometry;\r\nMeshBVH.prototype.closestPointToGeometry = function ( ...args ) {\r\n\r\n\tconst target1 = args[ 2 ];\r\n\tconst target2 = args[ 3 ];\r\n\tif ( target1 && target1.isVector3 || target2 && target2.isVector3 ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature and results frame for \"closestPointToGeometry\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst result1 = {};\r\n\t\tconst result2 = {};\r\n\t\tconst geometryToBvh = args[ 1 ];\r\n\t\targs[ 2 ] = result1;\r\n\t\targs[ 3 ] = result2;\r\n\r\n\t\toriginalClosestPointToGeometry.apply( this, args );\r\n\r\n\t\tif ( target1 ) {\r\n\r\n\t\t\ttarget1.copy( result1.point );\r\n\r\n\t\t}\r\n\r\n\t\tif ( target2 ) {\r\n\r\n\t\t\ttarget2.copy( result2.point ).applyMatrix4( geometryToBvh );\r\n\r\n\t\t}\r\n\r\n\t\treturn result1.distance;\r\n\r\n\t} else {\r\n\r\n\t\treturn originalClosestPointToGeometry.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\nconst originalRefit = MeshBVH.prototype.refit;\r\nMeshBVH.prototype.refit = function ( ...args ) {\r\n\r\n\tconst nodeIndices = args[ 0 ];\r\n\tconst terminationIndices = args[ 1 ];\r\n\tif ( terminationIndices && ( terminationIndices instanceof Set || Array.isArray( terminationIndices ) ) ) {\r\n\r\n\t\tconsole.warn( 'MeshBVH: The function signature for \"refit\" has changed. See docs for new signature.' );\r\n\r\n\t\tconst newNodeIndices = new Set();\r\n\t\tterminationIndices.forEach( v => newNodeIndices.add( v ) );\r\n\t\tif ( nodeIndices ) {\r\n\r\n\t\t\tnodeIndices.forEach( v => newNodeIndices.add( v ) );\r\n\r\n\t\t}\r\n\r\n\t\toriginalRefit.call( this, newNodeIndices );\r\n\r\n\t} else {\r\n\r\n\t\toriginalRefit.apply( this, args );\r\n\r\n\t}\r\n\r\n};\r\n\r\n[\r\n\t'intersectsGeometry',\r\n\t'shapecast',\r\n\t'intersectsBox',\r\n\t'intersectsSphere',\r\n].forEach( name => {\r\n\r\n\tconst originalFunc = MeshBVH.prototype[ name ];\r\n\tMeshBVH.prototype[ name ] = function ( ...args ) {\r\n\r\n\t\tif ( args[ 0 ] === null || args[ 0 ].isMesh ) {\r\n\r\n\t\t\targs.shift();\r\n\t\t\tconsole.warn( `MeshBVH: The function signature for \"${ name }\" has changed and no longer takes Mesh. See docs for new signature.` );\r\n\r\n\t\t}\r\n\r\n\t\treturn originalFunc.apply( this, args );\r\n\r\n\t};\r\n\r\n} );\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\nlet _nodeId = 0;\n\nclass Node {\n  constructor() {\n    let nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  get type() {\n    return this.constructor.name;\n  }\n\n  getHash() {\n    return this.uuid;\n  }\n\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  getNodeType() {\n    return this.nodeType;\n  }\n\n  update() {\n    console.warn('Abstract function.');\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n\n  build(builder) {\n    let output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n\n    builder.removeStack(this);\n    return snippet;\n  }\n\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n\n    let data = meta.nodes[uuid];\n\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNode.prototype.isNode = true;\nexport default Node;","map":{"version":3,"names":["NodeUpdateType","getNodesKeys","MathUtils","_nodeId","Node","constructor","nodeType","updateType","None","uuid","generateUUID","Object","defineProperty","value","type","name","getHash","getUpdateType","getNodeType","update","console","warn","generate","analyze","builder","hash","sharedNode","getNodeFromHash","undefined","nodeData","getDataFromNode","dependenciesCount","nodeKeys","property","build","output","addNode","addStack","isGenerateOnce","length","snippet","format","removeStack","serialize","json","inputNodes","toJSON","meta","deserialize","nodes","isRoot","textures","images","data","metadata","version","generator","extractFromCache","cache","values","key","push","prototype","isNode"],"sources":["/home/odin/Desktop/THPâ˜ /Developpeur/Final_Project/pokeland/node_modules/three-stdlib/nodes/core/Node.js"],"sourcesContent":["import { NodeUpdateType } from './constants.js';\nimport { getNodesKeys } from './NodeUtils.js';\nimport { MathUtils } from 'three';\n\nlet _nodeId = 0;\n\nclass Node {\n  constructor(nodeType = null) {\n    this.nodeType = nodeType;\n    this.updateType = NodeUpdateType.None;\n    this.uuid = MathUtils.generateUUID();\n    Object.defineProperty(this, 'id', {\n      value: _nodeId++\n    });\n  }\n\n  get type() {\n    return this.constructor.name;\n  }\n\n  getHash() {\n    return this.uuid;\n  }\n\n  getUpdateType() {\n    return this.updateType;\n  }\n\n  getNodeType() {\n    return this.nodeType;\n  }\n\n  update() {\n    console.warn('Abstract function.');\n  }\n\n  generate() {\n    console.warn('Abstract function.');\n  }\n\n  analyze(builder) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.analyze(builder);\n    }\n\n    const nodeData = builder.getDataFromNode(this);\n    nodeData.dependenciesCount = nodeData.dependenciesCount === undefined ? 1 : nodeData.dependenciesCount + 1;\n    const nodeKeys = getNodesKeys(this);\n\n    for (const property of nodeKeys) {\n      this[property].analyze(builder);\n    }\n  }\n\n  build(builder, output = null) {\n    const hash = this.getHash(builder);\n    const sharedNode = builder.getNodeFromHash(hash);\n\n    if (sharedNode !== undefined && this !== sharedNode) {\n      return sharedNode.build(builder, output);\n    }\n\n    builder.addNode(this);\n    builder.addStack(this);\n    const nodeData = builder.getDataFromNode(this);\n    const isGenerateOnce = this.generate.length === 1;\n    let snippet = null;\n\n    if (isGenerateOnce) {\n      const type = this.getNodeType(builder);\n      snippet = nodeData.snippet;\n\n      if (snippet === undefined) {\n        snippet = this.generate(builder) || '';\n        nodeData.snippet = snippet;\n      }\n\n      snippet = builder.format(snippet, type, output);\n    } else {\n      snippet = this.generate(builder, output) || '';\n    }\n\n    builder.removeStack(this);\n    return snippet;\n  }\n\n  serialize(json) {\n    const nodeKeys = getNodesKeys(this);\n\n    if (nodeKeys.length > 0) {\n      const inputNodes = {};\n\n      for (const property of nodeKeys) {\n        inputNodes[property] = this[property].toJSON(json.meta).uuid;\n      }\n\n      json.inputNodes = inputNodes;\n    }\n  }\n\n  deserialize(json) {\n    if (json.inputNodes !== undefined) {\n      const nodes = json.meta.nodes;\n\n      for (const property in json.inputNodes) {\n        const uuid = json.inputNodes[property];\n        this[property] = nodes[uuid];\n      }\n    }\n  }\n\n  toJSON(meta) {\n    const {\n      uuid,\n      type\n    } = this;\n    const isRoot = meta === undefined || typeof meta === 'string';\n\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {},\n        nodes: {}\n      };\n    } // serialize\n\n\n    let data = meta.nodes[uuid];\n\n    if (data === undefined) {\n      data = {\n        uuid,\n        type,\n        meta,\n        metadata: {\n          version: 4.5,\n          type: 'Node',\n          generator: 'Node.toJSON'\n        }\n      };\n      meta.nodes[data.uuid] = data;\n      this.serialize(data);\n      delete data.meta;\n    } // TODO: Copied from Object3D.toJSON\n\n\n    function extractFromCache(cache) {\n      const values = [];\n\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n\n      return values;\n    }\n\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const nodes = extractFromCache(meta.nodes);\n      if (textures.length > 0) data.textures = textures;\n      if (images.length > 0) data.images = images;\n      if (nodes.length > 0) data.nodes = nodes;\n    }\n\n    return data;\n  }\n\n}\n\nNode.prototype.isNode = true;\n\nexport default Node;\n"],"mappings":"AAAA,SAASA,cAAT,QAA+B,gBAA/B;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,SAAT,QAA0B,OAA1B;AAEA,IAAIC,OAAO,GAAG,CAAd;;AAEA,MAAMC,IAAN,CAAW;EACTC,WAAW,GAAkB;IAAA,IAAjBC,QAAiB,uEAAN,IAAM;IAC3B,KAAKA,QAAL,GAAgBA,QAAhB;IACA,KAAKC,UAAL,GAAkBP,cAAc,CAACQ,IAAjC;IACA,KAAKC,IAAL,GAAYP,SAAS,CAACQ,YAAV,EAAZ;IACAC,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC;MAChCC,KAAK,EAAEV,OAAO;IADkB,CAAlC;EAGD;;EAEO,IAAJW,IAAI,GAAG;IACT,OAAO,KAAKT,WAAL,CAAiBU,IAAxB;EACD;;EAEDC,OAAO,GAAG;IACR,OAAO,KAAKP,IAAZ;EACD;;EAEDQ,aAAa,GAAG;IACd,OAAO,KAAKV,UAAZ;EACD;;EAEDW,WAAW,GAAG;IACZ,OAAO,KAAKZ,QAAZ;EACD;;EAEDa,MAAM,GAAG;IACPC,OAAO,CAACC,IAAR,CAAa,oBAAb;EACD;;EAEDC,QAAQ,GAAG;IACTF,OAAO,CAACC,IAAR,CAAa,oBAAb;EACD;;EAEDE,OAAO,CAACC,OAAD,EAAU;IACf,MAAMC,IAAI,GAAG,KAAKT,OAAL,CAAaQ,OAAb,CAAb;IACA,MAAME,UAAU,GAAGF,OAAO,CAACG,eAAR,CAAwBF,IAAxB,CAAnB;;IAEA,IAAIC,UAAU,KAAKE,SAAf,IAA4B,SAASF,UAAzC,EAAqD;MACnD,OAAOA,UAAU,CAACH,OAAX,CAAmBC,OAAnB,CAAP;IACD;;IAED,MAAMK,QAAQ,GAAGL,OAAO,CAACM,eAAR,CAAwB,IAAxB,CAAjB;IACAD,QAAQ,CAACE,iBAAT,GAA6BF,QAAQ,CAACE,iBAAT,KAA+BH,SAA/B,GAA2C,CAA3C,GAA+CC,QAAQ,CAACE,iBAAT,GAA6B,CAAzG;IACA,MAAMC,QAAQ,GAAG/B,YAAY,CAAC,IAAD,CAA7B;;IAEA,KAAK,MAAMgC,QAAX,IAAuBD,QAAvB,EAAiC;MAC/B,KAAKC,QAAL,EAAeV,OAAf,CAAuBC,OAAvB;IACD;EACF;;EAEDU,KAAK,CAACV,OAAD,EAAyB;IAAA,IAAfW,MAAe,uEAAN,IAAM;IAC5B,MAAMV,IAAI,GAAG,KAAKT,OAAL,CAAaQ,OAAb,CAAb;IACA,MAAME,UAAU,GAAGF,OAAO,CAACG,eAAR,CAAwBF,IAAxB,CAAnB;;IAEA,IAAIC,UAAU,KAAKE,SAAf,IAA4B,SAASF,UAAzC,EAAqD;MACnD,OAAOA,UAAU,CAACQ,KAAX,CAAiBV,OAAjB,EAA0BW,MAA1B,CAAP;IACD;;IAEDX,OAAO,CAACY,OAAR,CAAgB,IAAhB;IACAZ,OAAO,CAACa,QAAR,CAAiB,IAAjB;IACA,MAAMR,QAAQ,GAAGL,OAAO,CAACM,eAAR,CAAwB,IAAxB,CAAjB;IACA,MAAMQ,cAAc,GAAG,KAAKhB,QAAL,CAAciB,MAAd,KAAyB,CAAhD;IACA,IAAIC,OAAO,GAAG,IAAd;;IAEA,IAAIF,cAAJ,EAAoB;MAClB,MAAMxB,IAAI,GAAG,KAAKI,WAAL,CAAiBM,OAAjB,CAAb;MACAgB,OAAO,GAAGX,QAAQ,CAACW,OAAnB;;MAEA,IAAIA,OAAO,KAAKZ,SAAhB,EAA2B;QACzBY,OAAO,GAAG,KAAKlB,QAAL,CAAcE,OAAd,KAA0B,EAApC;QACAK,QAAQ,CAACW,OAAT,GAAmBA,OAAnB;MACD;;MAEDA,OAAO,GAAGhB,OAAO,CAACiB,MAAR,CAAeD,OAAf,EAAwB1B,IAAxB,EAA8BqB,MAA9B,CAAV;IACD,CAVD,MAUO;MACLK,OAAO,GAAG,KAAKlB,QAAL,CAAcE,OAAd,EAAuBW,MAAvB,KAAkC,EAA5C;IACD;;IAEDX,OAAO,CAACkB,WAAR,CAAoB,IAApB;IACA,OAAOF,OAAP;EACD;;EAEDG,SAAS,CAACC,IAAD,EAAO;IACd,MAAMZ,QAAQ,GAAG/B,YAAY,CAAC,IAAD,CAA7B;;IAEA,IAAI+B,QAAQ,CAACO,MAAT,GAAkB,CAAtB,EAAyB;MACvB,MAAMM,UAAU,GAAG,EAAnB;;MAEA,KAAK,MAAMZ,QAAX,IAAuBD,QAAvB,EAAiC;QAC/Ba,UAAU,CAACZ,QAAD,CAAV,GAAuB,KAAKA,QAAL,EAAea,MAAf,CAAsBF,IAAI,CAACG,IAA3B,EAAiCtC,IAAxD;MACD;;MAEDmC,IAAI,CAACC,UAAL,GAAkBA,UAAlB;IACD;EACF;;EAEDG,WAAW,CAACJ,IAAD,EAAO;IAChB,IAAIA,IAAI,CAACC,UAAL,KAAoBjB,SAAxB,EAAmC;MACjC,MAAMqB,KAAK,GAAGL,IAAI,CAACG,IAAL,CAAUE,KAAxB;;MAEA,KAAK,MAAMhB,QAAX,IAAuBW,IAAI,CAACC,UAA5B,EAAwC;QACtC,MAAMpC,IAAI,GAAGmC,IAAI,CAACC,UAAL,CAAgBZ,QAAhB,CAAb;QACA,KAAKA,QAAL,IAAiBgB,KAAK,CAACxC,IAAD,CAAtB;MACD;IACF;EACF;;EAEDqC,MAAM,CAACC,IAAD,EAAO;IACX,MAAM;MACJtC,IADI;MAEJK;IAFI,IAGF,IAHJ;IAIA,MAAMoC,MAAM,GAAGH,IAAI,KAAKnB,SAAT,IAAsB,OAAOmB,IAAP,KAAgB,QAArD;;IAEA,IAAIG,MAAJ,EAAY;MACVH,IAAI,GAAG;QACLI,QAAQ,EAAE,EADL;QAELC,MAAM,EAAE,EAFH;QAGLH,KAAK,EAAE;MAHF,CAAP;IAKD,CAbU,CAaT;;;IAGF,IAAII,IAAI,GAAGN,IAAI,CAACE,KAAL,CAAWxC,IAAX,CAAX;;IAEA,IAAI4C,IAAI,KAAKzB,SAAb,EAAwB;MACtByB,IAAI,GAAG;QACL5C,IADK;QAELK,IAFK;QAGLiC,IAHK;QAILO,QAAQ,EAAE;UACRC,OAAO,EAAE,GADD;UAERzC,IAAI,EAAE,MAFE;UAGR0C,SAAS,EAAE;QAHH;MAJL,CAAP;MAUAT,IAAI,CAACE,KAAL,CAAWI,IAAI,CAAC5C,IAAhB,IAAwB4C,IAAxB;MACA,KAAKV,SAAL,CAAeU,IAAf;MACA,OAAOA,IAAI,CAACN,IAAZ;IACD,CAhCU,CAgCT;;;IAGF,SAASU,gBAAT,CAA0BC,KAA1B,EAAiC;MAC/B,MAAMC,MAAM,GAAG,EAAf;;MAEA,KAAK,MAAMC,GAAX,IAAkBF,KAAlB,EAAyB;QACvB,MAAML,IAAI,GAAGK,KAAK,CAACE,GAAD,CAAlB;QACA,OAAOP,IAAI,CAACC,QAAZ;QACAK,MAAM,CAACE,IAAP,CAAYR,IAAZ;MACD;;MAED,OAAOM,MAAP;IACD;;IAED,IAAIT,MAAJ,EAAY;MACV,MAAMC,QAAQ,GAAGM,gBAAgB,CAACV,IAAI,CAACI,QAAN,CAAjC;MACA,MAAMC,MAAM,GAAGK,gBAAgB,CAACV,IAAI,CAACK,MAAN,CAA/B;MACA,MAAMH,KAAK,GAAGQ,gBAAgB,CAACV,IAAI,CAACE,KAAN,CAA9B;MACA,IAAIE,QAAQ,CAACZ,MAAT,GAAkB,CAAtB,EAAyBc,IAAI,CAACF,QAAL,GAAgBA,QAAhB;MACzB,IAAIC,MAAM,CAACb,MAAP,GAAgB,CAApB,EAAuBc,IAAI,CAACD,MAAL,GAAcA,MAAd;MACvB,IAAIH,KAAK,CAACV,MAAN,GAAe,CAAnB,EAAsBc,IAAI,CAACJ,KAAL,GAAaA,KAAb;IACvB;;IAED,OAAOI,IAAP;EACD;;AArKQ;;AAyKXjD,IAAI,CAAC0D,SAAL,CAAeC,MAAf,GAAwB,IAAxB;AAEA,eAAe3D,IAAf"},"metadata":{},"sourceType":"module"}